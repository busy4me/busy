#!/bin/bash
# Slimming Linux bootstrap script, Author: Visaroy <visaroy@gmail.com>
# used to slim Linux distributions, remove unnecessary things, packages, files, dirs, manuals, logs, etc.
# The main goals are: save a lot of space on root filesystem and prepare distro for specific tasks.
# Install only the packages you need, eg. when you need web browser xorg+firefox you do not need vim
# Comments with double ## are in help option -h or --help
# try: /usr/bin/initiv -h
## * Usage: /usr/bin/initiv [-o]... [parameter]... <action>
## where -o is option with or without parameter
## initiv install - to prepare installation (after that, distro is redy for cloning)

# Everything below will go to the file 'initiv.log':
_LOGFILE=/var/log/busy4me.log # default colorful log file, check cat /var/log/busy4me.log
_START=$(date +%s) # calculate how long script runs (see on the end)
_EXECUTOR_PATH=`pwd`
_SCRIPT_PATH="/usr/bin"
_SCRIPT_NAME="initiv"
_SCRIPT_VERSION="$(date +%Y-%m-%d)"
_SCRIPT_FULL_NAME="$0"
_SCRIPT_ARGUMENTS="$*"
_DATE_STAMP="$(date +%Y-%m-%d--%H-%M-%S)"
_BUSY_SERVICE=busy4me # main service, watchdog, checks other busy4me precesses
_BUSY_ANIME_SERVICE=busy-anime # animation in framebuffer, durring 'initiv 0' installation process
_INITIV_1_SERVICE=initiv-1 # trigger 'initiv -S 1' installation process, visible in xterm, first X run
_SERVER="http://busy4.me"
_SERVER_DIR="/busy"
_USER="busyman" # default user name
#_PASS="busy" # default user password
_THEME=dark # default installation theme, used in __xt and __anime functions
_BG=black # default background color, used by xterm option -bg
_FG=grey # default foreground color, used by xterm option -fg
_SALT_DIR="/etc/salt"
_SALT_MASTER="192.168.121.250"
_SALT_MINION=$(cat /sys/class/dmi/id/product_uuid) # temporary Salt Minion ID, later will change to hostname
# change hostname to present IP
exec &> >(tee -ia $_LOGFILE)
exec 2>&1
echo "_EXECUTOR_PATH=$_EXECUTOR_PATH"

. /usr/bin/bashcolors
echo -e "${lblu}o${gre}o${cya}o${red}o${mag}o${yel}o${gre}o${lbla}o${lblu}o${gre}o${cya}o${red}\
o${mag}o${yel}o${whi}o${lbla}o${whi}o${yel}o${mag}o${red}o${cya}o${gre}o${lblu}o${lbla}o${gre}\
o${yel}o${mag}o${red}o${cya}o${gre}o${lblu}o${lblu}
_SCRIPT_ARGUMENTS=$_SCRIPT_ARGUMENTS ${coloroff}" 2>/dev/null

__net_status () {
	[[ $_SKIP_NET == "true" ]] && return
	_HOST=$(echo $1 | sed 's/http:\/\///g' | sed 's/https:\/\///g')
	echofunc ${FUNCNAME[0]} $@
	echofunc ${FUNCNAME[0]}
	echook "host: $_HOST"
#	_IP=$(ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sed 's/127.0.0.1//' | tr '\n' ' ')
if [ ! "$_IP_STATUS" == "OK" ]; then
	while [ -z "$_IP" ];	do
		_IP=$(ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sed 's/127.0.0.1//' | tr '\n' ' ' | sed 's/[[:space:]]//g')
		echo "waiting for IP address... check... _IP=$_IP"
		sleep 1
	done
	[[ -n "$_IP" ]] && { _IP_STATUS="OK"; echook "_IP_STATUS=$_IP_STATUS"; }
fi

if [ ! -z $_HOST ]; then
	wget --no-check-certificate -q --tries=10 --timeout=20 --spider http://$_HOST
	if [[ $? -eq 0 ]]; then
			_HOST_STATUS="OK"
	    echook "$_HOST online response with 0 error code :) _HOST_STATUS=OK"
	else
			"$_HOST"_STATUS="no response"
	    echoerror "$_HOST offline? response with 0 error code :("
	fi
fi

if [ -x "$(command -v nc)" ]; then
	nc -z 8.8.8.8 53  >/dev/null 2>&1
	online=$?
	if [ $online -eq 0 ]; then
	    echook "DNS server 8.8.8.8 response OK :)"
			_DNS_STATUS="OK"
	else
	    echoerror "DNS server 8.8.8.8 not response, offline :(";
			_DNS_STATUS="no response"
	fi
fi
}

# read all function first! All execution at the bottom.
__bashcolor () {
	echofunc ${FUNCNAME[0]}
# set bashcolors ===============================================================
# __net_status $_SERVER
if ! wget -q -nv -O /usr/bin/bashcolors --no-check-certificate $_SERVER/bashcolors; then
	echoerror "OFFLINE! ...can't connect to bashcolors in $_SERVER"
fi
}

## -- Function -- __update -------------------------------------------------------------------------
## |    Description: update initiv itself                                                          |
## -------------------------------------------------------------------------------------------------
__update () { #help: /usr/bin/initiv update itself
	[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
	echofunc ${FUNCNAME[0]}
	echoinfo "_UPDATE=$_UPDATE"
	if [[ "$_UPDATE" == "no" || "$_UPDATE" == "false" ]]; then
		return 0
	else
		echoinfo "_UPDATE=yes, continue update ..."
	fi
	# initive should be always in /usr/bin directory, so even will be downloaded in different location
	# will change itself
	if [ ! "$_SCRIPT_FULL_NAME" == "/usr/bin/initiv" ]; then
		echowarning "$_SCRIPT_FULL_NAME in wrong location, quick fix ..."
		cp $_SCRIPT_FULL_NAME /usr/bin/initiv
		chmod +x /usr/bin/initiv
		rm $_SCRIPT_FULL_NAME
		echo "run again from correct position: " /usr/bin/initiv $_SCRIPT_ARGUMENTS
		/usr/bin/initiv $_SCRIPT_ARGUMENTS
		exit 0
	else
		echoconfirm "$_SCRIPT_FULL_NAME ... correct"
	fi

	echoinfo " ..download update on server $_SERVER"
	__net_status $_SERVER
		echo -e "$0 \e[32m -- Update $_SCRIPT_VERSION $_DATE_STAMP\e[0m"
	if ! wget -nv -O /usr/bin/initiv.new --no-check-certificate $_SERVER/initiv; then
		echoerror "there is no file "$0" on the server or no response!..."
		exit 1
	else
		echoinfo " ... compare version"
		_NEW="$(cat /usr/bin/initiv.new | base64)"
		_OLD="$(cat /usr/bin/initiv | base64)"
		if [ ! "$_NEW" == "$_OLD" ]; then
			echowarning " ... version on the server is different, update and start again..."
			rm -rf /usr/bin/initiv-*
			cp /usr/bin/initiv /usr/bin/initiv-$_DATE_STAMP # backup just in case
			rm -rf /usr/bin/initiv
			cp /usr/bin/initiv.new /usr/bin/initiv 2>/dev/null
			chmod +x /usr/bin/initiv
			rm -rf /usr/bin/initiv.new
			echo "run again: $_SCRIPT_FULL_NAME $_SCRIPT_ARGUMENTS"
			$_SCRIPT_FULL_NAME $_SCRIPT_ARGUMENTS &
			exit 0
		else
			echoconfirm " ... no update needed, identical version on the server"
		fi
	fi
	echoconfirm "${FUNCNAME[0]} done"
}

__change_hostname () { #help: change hostname mached IP address, also used for waiting IP from DHCP
	echofunc ${FUNCNAME[0]}
	_UUID=$(cat /sys/class/dmi/id/product_uuid | sed 's/.*-//')
	_HWMAC=$(cat /sys/class/dmi/id/product_uuid | cut -c 33-) # last four characters
	_MAC=$(cat /sys/class/net/$(ip route show default | awk '/default/ {print $5}')/address | tr ':' ' ' | tr '\n' ' ' | sed 's/[[:space:]]//g')
	_NETMAC=$(echo $_MAC | cut -c 7-) # last six characters
	_IP=$(ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sed 's/127.0.0.1//' | tr '\n' ' ')
	_IP_END=$(echo $_IP | sed 's/.*\.//')
	_EXT_IP=$(curl -s http://icanhazip.com | tr '\n' ' ' | sed 's/[[:space:]]//g')
# ========================================================================================
# === hostname structure:                                                              ===
# === HWMAC (dash) NETMAC last six characters                                          ===
# === where: HWMAC - last four characters of hardware UUID                             ===
# ===        NETMAC - last six characters of network card MAC address                  ===
# === eg.:   e733-acb52e                                                               ===
# ========================================================================================
	_NEW_HOSTNAME="$_HWMAC-$_NETMAC"
	_OLD_HOSTNAME=$(cat /etc/hostname)
	if [ ! "$_OLD_HOSTNAME" == "$_NEW_HOSTNAME" ];	then
		echoinfo " _OLD_HOSTNAME=$_OLD_HOSTNAME  ...set new hostname: _NEW_HOSTNAME=$_NEW_HOSTNAME"
		hostnamectl set-hostname $_NEW_HOSTNAME
		echo "   ...update /etc/hosts file"
		cp /etc/hosts /etc/hosts.bak 2>/dev/null
		sed -i "/\s$_OLD_HOSTNAME/d" /etc/hosts
		echo "127.0.1.1 $_NEW_HOSTNAME" >> /etc/hosts
	else
		echoconfirm " hostname unchaged: _OLD_HOSTNAME=$_OLD_HOSTNAME _NEW_HOSTNAME=$_NEW_HOSTNAME"
	fi
}

__distro () { #help: check distro and set server
echofunc ${FUNCNAME[0]}
	# server structure /.initiv/debian/10.3/x86_64/
	if [ -f /etc/os-release ]; then
	. /etc/os-release
		_ID=$ID
		_VERSION_CODENAME=$VERSION_CODENAME
		_VERSION_ID=$VERSION_ID
	else
		echoerror "can\'t find /etc/os-release"
	fi
	if [ -f /etc/debian_version ]; then
		_VER=$(cat /etc/debian_version)
	else
		echoerror "can\'t find /etc/debian_version"
	fi
	_ARCH=$(uname -m)
	_KERNEL_RELEASE="$(uname -r)"
	# CAUTION! there is "dot" in script name
	echoinfo "server distribution path: $_SERVER/.$_SCRIPT_NAME/$_ID/$_VER/$_ARCH"
}

__fix () { #help: fix possible problems with filesystem, databeses, apt, dpkg etc.
echofunc ${FUNCNAME[0]}
/usr/share/debconf/fix_db.pl # avoid problem with debconf corruption
update-default-wordlist
dpkg --configure -a # if dpkg was interrupted, correct the problem.
dpkg-reconfigure -u dictionaries-common
}

## -- Function -- __useradd -------------------------------------------------------------------------
## |    Description: Add user and set password (default user: busyman without password)               |
## |         Option: -U [user]                                                                        |
## |        Caution: AFTER CREATE USER THE CONSOLE tty1 WILL BE RESTARTED IMMEDIATELY and NEW USER    |
## |                 WILL START WORK IN NEW X SESSION                                                 |
## |           user: user's name                                                                      |
## |       Examples: /usr/bin/initiv -U kate # create user "kate" and allow use crontab                      |
##----------------------------------------------------------------------------------------------------
__useradd () { #help: add user
	echofunc "${FUNCNAME[0]}"
	echoinfo "_USER=$_USER"
	/usr/sbin/groupadd $_USER 2>/dev/null
	/usr/sbin/useradd -r -s /bin/bash -m -g $_USER $_USER 2>/dev/null
#	useradd -p $(openssl passwd -1 $_PASS) -r -s /bin/bash -m -g $_USER $_USER 2>/dev/null
	/usr/sbin/usermod -a -G "cdrom,floppy,dip,plugdev,netdev,audio,video" $_USER
# add user to sudoers and allow execute commands without password
	/usr/sbin/usermod -a -G "sudo" $_USER
	echo "$_USER	ALL=(ALL:ALL) NOPASSWD:ALL" >> /etc/sudoers

	_CAF="/etc/cron.allow" # Cron Allow File
if ! grep -q $_USER $_CAF; then
	echo "$_USER" >> $_CAF
	echoconfirm "$_USER added to $_CAF"
else
	echoinfo "$_USER already exists in $_CAF"
fi
echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __autologin -------------------------------------------------------------------------
## |    Description: Autologin as $_USER user without login manager in console tty1...                |
## |         Option: -a [user]                                                                        |
## |           user: existing user name                                                               |
## |       Examples: /usr/bin/initiv -a kate # set "kate" user automaticaly logged in tty1                   |
## ----------------------------------------------------------------------------------------------------
##
__autologin () { #help: set autologin, who will be automaticaly logged in
echofunc "${FUNCNAME[0]}"
if [ ! "$1" == "root" ]; then
	# autologin as user in tty1
	echoinfo "_AUTOUSER=$_USER"
	_AUTOUSER=$_USER
	echo -e "\e[32m Autologin as \e[95m$_USER\e[0m user without login manager in console tty1...\e[0m"
	rm -R /etc/systemd/system/getty@tty1.service.d 2>/dev/null
	mkdir -pv /etc/systemd/system/getty@tty1.service.d 2>/dev/null
cat > /etc/systemd/system/getty@tty1.service.d/autologin.conf << EOF
[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin $_AUTOUSER --noclear %I $TERM
EOF

else
	echoinfo "_AUTOUSER=$1"
	# autologin as root in tty1
rm -R /etc/systemd/system/getty@tty1.service.d 2>/dev/null
mkdir -pv /etc/systemd/system/getty@tty1.service.d 2>/dev/null
cat > /etc/systemd/system/getty@tty1.service.d/autologin.conf << EOF
[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin root --noclear %I $TERM
EOF
fi

# autologin as root in tty2
rm -R /etc/systemd/system/getty@tty2.service.d 2>/dev/null
mkdir -pv /etc/systemd/system/getty@tty2.service.d 2>/dev/null
cat > /etc/systemd/system/getty@tty2.service.d/autologin.conf << EOF
[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin root --noclear %I $TERM
EOF

systemctl set-default multi-user.target
echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __autostart -------------------------------------------------------------------------
## |    Description: set startx after autologing and applications after X starts                      |
## ----------------------------------------------------------------------------------------------------
## |
__autostart () {
	echofunc "${FUNCNAME[0]}"
	if [ ! "$1" == "root" ]; then
		echoinfo "_AUTOUSER=$_USER set startx after autologing and applications after X starts..."
		cp /home/$_USER/.profile /home/$_USER/.profile.bak 2>/dev/null
		rm /home/$_USER/.profile 2>/dev/null
		# [[ $(tty) = /dev/tty1 ]] && setterm -blank 0 -powersave off && startx -- vt1 &> /dev/null
cat > /home/$_USER/.profile  << 'EOF'
[[ $(tty) = /dev/tty1 ]] && setterm -blank 0 -powersave off && startx -- vt1 &> /dev/null
EOF
		chown $_USER:$_USER /home/$_USER/.profile

		cp /home/$_USER/.xinitrc /home/$_USER/.xinitrc.bak 2>/dev/null
		rm /home/$_USER/.xinitrc 2>/dev/null
cat > /home/$_USER/.xinitrc  << 'EOF'
#xclock
/opt/anime.sh &
/opt/xt.sh
#/opt/osd.sh
EOF
		chown $_USER:$_USER /home/$_USER/.xinitrc
		systemctl set-default multi-user.target
		# autostart root in tty2
cat > /root/.profile  << EOF
[[ \$(tty) = /dev/tty2 ]] && \\
(ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sed 's/127.0.0.1//' | tr '\n' ' ')
EOF

	else
		_UPDATE="/usr/bin/initiv update"
		case $_THEME in
			light)
			_LINE="/usr/bin/initiv -H light -k 0"  # -k skip update
			;;
			*)
			_LINE="/usr/bin/initiv -k 0"  # -k skip update
			;;
		esac
		echoinfo "_AUTOUSER=$1 run 'initiv 0' after restart tty1..."
cat > /root/.profile  << EOF
[[ \$(tty) = /dev/tty1 ]] && \\
(ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sed 's/127.0.0.1//' | tr '\n' ' ') && $_UPDATE && $_LINE
EOF
	fi
}

secs_to_human() {
    if [[ -z ${1} || ${1} -lt 60 ]] ;then
        min=0 ; secs="${1}"
    else
        time_mins=$(echo "scale=2; ${1}/60" | bc)
        min=$(echo ${time_mins} | cut -d'.' -f1)
        secs="0.$(echo ${time_mins} | cut -d'.' -f2)"
        secs=$(echo ${secs}*60|bc|awk '{print int($1+0.5)}')
    fi
    echo "Time Elapsed : ${min} minutes and ${secs} seconds."
}

# set echo types
echoerror() {
    printf "${lred}   * ERROR${lred}: %s${nocolor}\\n" "$@" 1>&2;
}

echowarning() {
    printf "${lyel}   * WARNING: %s ${nocolor}\\n" "$@" 1>&2;
}

echoinfo() {
    printf "${lblu} * INFO${lcya}: %s ${nocolor}\\n" "$@" 1>&2;
}

echoconfirm() {
    printf "${mag}   * CONFIRM${lmag}: %s ${nocolor}\\n" "$@" 1>&2;
}

echofunc() {
    printf "${lwhi} * FUNCTION${lwhi}: %s${nocolor}\\n" "$@" 1>&2;
}

echook() {
    printf "${lgre}    * OK${gre}: %s${nocolor}\\n" "$@" 1>&2;
}
if [ ! "$USER" == "root" ]; then
	echowarning "... ### run this script as root to get full functionality ### ..."
fi

## -- Function -- __create_recovery -------------------------------------------------------------------
## |    Description: create initivRecovery file, used in emergency when update goes wrong.            |
## |          Usage: /usr/bin/initivRecovery                                                                 |
## |                 Script /usr/bin/initivRecovery removes badly updated /usr/bin/initiv and copy from last        |
## |                 backup file /usr/bin/initiv-*                                                           |
## ----------------------------------------------------------------------------------------------------
##
__create_recovery () {
	echofunc "${FUNCNAME[0]}"
# create recovery script 'initiv-recovery', to be using in emergency case, eg.when update went wrong
echoinfo "_SCRIPT_PATH: $_SCRIPT_PATH/initivRecovery"
cat > $_SCRIPT_PATH/initivRecovery  << EOF
#/bin/bash
rm /usr/bin/initiv
cp /usr/bin/initiv-* /usr/bin/initiv
EOF
chmod +x /usr/bin/initivRecovery
}

# reset (restart) Xserver (xinit) in tty1
## -- Function -- __reset -----------------------------------------------------------------------------
## |    Description: reset xinit and Xserver in default tty1                                          |
## ----------------------------------------------------------------------------------------------------
__reset () {
	echofunc "${FUNCNAME[0]}"
	echoinfo "tty1 stop"
	if [ -x "$(command -v sudo)" ]; then
		sudo /sbin/service getty@tty1 stop
		(sleep 2; sudo /sbin/service getty@tty1 restart) &
		echoinfo "tty2 stop"
		sudo /sbin/service getty@tty2 stop
		(sleep 5; sudo /sbin/service getty@tty2 restart) &
	else
		bash -c $(/sbin/service getty@tty1 stop)
		(sleep 2; /sbin/service getty@tty1 restart) &
		echoinfo "tty2 stop"
		bash -c $(/sbin/service getty@tty2 stop)
		(sleep 5; /sbin/service getty@tty2 restart) &
	fi
	echoinfo "${FUNCNAME[0]} ... done"
}


## -- Function -- __add_to_path -----------------------------------------------------------------------
## |    Description: add initiv to path                                                               |
## |    not used                                                               |
## ----------------------------------------------------------------------------------------------------
__add_to_path () {
	echo "PATH="$PATH
	case "$(echo $PATH)" in
	  *"/root"*)
		echoinfo "PATH contains: $_SCRIPT_PATH"
	  ;;
	  *)
		echowarning "add to path ... "$_SCRIPT_PATH
	  PATH=$PATH:/stratum; export PATH
		sed -i 's/export PATH=$PATH:\/root//g' ~/.profile
	  echo 'export PATH=$PATH:'$_SCRIPT_PATH  >> ~/.profile
	  ;;
	esac
}

## -- Function -- __read_data -------------------------------------------------------------------------
## |    Description: read data                                                                        |
## ----------------------------------------------------------------------------------------------------
__read_data () {
case $1 in
	"theme")
	_THEME=$(<"/opt/xt.theme")
		echo "read theme: $_THEME"
		case $_THEME in
			"light")
			echo "set _BG _FG for light theme..."
				_BG="white"
				_FG="black"
			;;
			"dark"|*)
			echo "set _BG _FG for dark theme..."
				_BG="black"
				_FG="grey"
			;;
		esac
	;;
esac
echofunc "${FUNCNAME[0]}"
# rm /usr/bin/initivData
echo $_DATE_STAMP " - disk usage:" $(df -H | grep -vE 'Filesystem|tmpfs|cdom' | grep /dev/ | awk '{ print $1 " " $3 }') >> /usr/bin/initivData
_DISK=$(echo $_DATE_STAMP " - disk usage:" $(df -H | grep -vE 'Filesystem|tmpfs|cdom'| grep /dev/ | awk '{ print $1 " " $3 }'))
# | tr '\n' ' '
echoinfo "read disk usage ..." | tr '\n' ' '
echo $_DISK
}

## -- Function -- __remove_packages -------------------------------------------------------------------
## |    Description: remove packages                                                                  |
## ----------------------------------------------------------------------------------------------------
__remove_packages () {
	echofunc "${FUNCNAME[0]}"
# I did try remove: "ispell", but sometimes :/ needs interactive answer, hmmm
# "keyboard-configuration"
	declare -a _PACKAGES=(
	"acpi"
	"acpid"
	"eject"
#	"gcc-4.8-base:amd64"
	"os-prober"
	"laptop-detect"
	"manpages"
	"nano"
	"tasksel"
	"traceroute"
	"usbutils"
	"vim-common"
	"vim-tiny"
	"console-setup"
	"discover"
	"installation-report"
	"kbd"
	"xxd"
#	"libc-l10n"
	"pciutils"
	"apparmor"
	)
		for _PACKAGE in ${_PACKAGES[@]}; do
			echoinfo "remove package: $_PACKAGE ............................. wait ..."
			apt-get -qq purge $_PACKAGE
		done
	apt-get -qq autoremove
	apt-get clean
	echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __update_apt_repos ------------------------------------------------------------------
## |    Description: update apt                                                                       |
## ----------------------------------------------------------------------------------------------------
__update_apt_repos () {
	[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
	echofunc ${FUNCNAME[0]}
	cp /etc/apt/sources.list /etc/apt/sources.list.bak; rm /etc/apt/sources.list
		#add main repo Debian 8 Jessie
		#echo 'deb http://ftp.debian.org/debian jessie main' >> /etc/apt/sources.list
#add main repo Debian 10 Buster
cat > /etc/apt/sources.list << EOF
deb http://deb.debian.org/debian buster main
#deb-src http://deb.debian.org/debian buster main
deb http://deb.debian.org/debian-security/ buster/updates main
#deb-src http://deb.debian.org/debian-security/ buster/updates main
deb http://deb.debian.org/debian buster-updates main
#deb-src http://deb.debian.org/debian buster-updates main
EOF
apt update
echoconfirm "${FUNCNAME[0]} done"
}

function __output () {
	echofunc ${FUNCNAME[0]}
	_FUNC=$1
	if [[ $_SHOW == "true" ]]; then
		export DISPLAY=:0
		export XAUTHORITY='/home/'$_USER'/.Xauthority'
		echowarning "_SHOW=$_SHOW execute in xterm in DISPLAY=$DISPLAY"
		__read_data theme
		xterm -geometry 110x6+10+36 -bw 0 -uc -bg $_BG -fg $_FG -e "$_SCRIPT_FULL_NAME -N $_FUNC"
	else
		echoinfo "standard output ..."
	fi
}

## -- Function -- __install ---------------------------------------------------------------------------
## |    Description: install grub2-splashimages fbi dbus openssh-server |
## ----------------------------------------------------------------------------------------------------
__install () { #help: usege /usr/bin/initiv -i package or /usr/bin/initiv __install - to install basic packages
	[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
	echofunc ${FUNCNAME[0]}
	echoinfo " ... install basic for frepare splash and first boot ..."
# if used short name "ssh" then openssh-server will be installed
# usage: /usr/bin/initiv -i ssh
#
	[[ "$_PACKAGE" = "ssh" ]] &&	{ \
		echoinfo "install openssh-server..  wait...."; \
		apt-get install -y -qq --no-install-recommends openssh-server; exit 0; }

	if [ -z $1 ]; then
		declare -a stuff=(
		"grub2-splashimages"
		"fbi"
		"dbus"
		"openssh-server"
		)
		for _PACKAGE in ${stuff[@]}; do
			echoinfo "install package: $_PACKAGE ............................. wait ..."
			apt-get install -y -qq --no-install-recommends $_PACKAGE
		done
	else
		echo "install $1 ....................."
		apt-get install -y -qq --no-install-recommends $1
	fi
	echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __install_stuff1 --------------------------------------------------------------------
## |    Description: install openssh-server, openssl, bc, xloadimage, xli, xosd-bin, parted           |
## ----------------------------------------------------------------------------------------------------
__install_stuff1 () {
	[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
	echofunc ${FUNCNAME[0]}
	echoinfo " ... install stuff from official repositories ..."
	if [ -z $1 ]; then
		echo "en_US.UTF-8 UTF-8" > /etc/locale.gen
		declare -a stuff=(
		"locales"
		"sudo"
		"openssl"
		"bc"
		"xloadimage"
		"xli"
		"xosd-bin"
		"parted"
		)
		for _PACKAGE in ${stuff[@]}; do
			echoinfo "install package: $_PACKAGE ............................. wait ..."
			apt-get install -y -qq --no-install-recommends $_PACKAGE
		done
	else
		_PACKAGE=$1
		echoinfo "install package: $_PACKAGE ............................. wait ..."
		apt-get install -y -qq --no-install-recommends $_PACKAGE
	fi
	echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __install_stuff2 --------------------------------------------------------------------
## |    Description: install stuff 2                                                                  |
## |         Option: -apt2 |installStuff2                                                             |
## |       Examples: /usr/bin/initiv -apt2                                                                   |
## ----------------------------------------------------------------------------------------------------
__install_stuff2 () {
	[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
	echofunc ${FUNCNAME[0]}
	echoinfo " ... install stuff2 from Debian repositories ..."
# install stuff during "installation ..." message
# "software-properties-common" may be not needed
# "nginx" not needed, old idea to use as interactive menu

declare -a stuff2=(
"curl"
"wget"
"openbox"
"xdotool"
"wmctrl"
"netcat"
"xcompmgr"
"feh"
"bc"
"ntp"
"zenity"
"xclip"
"ntpdate"
"scrot"
"screen"
"sqlite3"
"xvfb"
"tint2"
"psmisc"
"ffmpeg"
"python"
"python-dev"
"python-tk"
"python-pip"
"python-xlib"
"python-pillow"
)
	for _PACKAGE in ${stuff2[@]}; do
		echoinfo "install package: $_PACKAGE ............................. wait ..."
		apt-get install -y -qq --no-install-recommends $_PACKAGE
	done
pip install wheel # need for tzupdate using geolocation from Chris Down https://github.com/cdown/tzupdate
pip install -U tzupdate # update time zone
pip install setuptools -U # update 08-2019,
pip install pyautogui # need for automate keys, mouse, recognise pictures on the screen
echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __install_stuff3 --------------------------------------------------------------------
## |    Description: install google chrome                                                            |
## |         Option: -apt3                                                                            |
## |       Examples: /usr/bin/initiv -apt3                                                                   |
## ----------------------------------------------------------------------------------------------------
__install_stuff3 () {
	[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
	echofunc ${FUNCNAME[0]}
	echoinfo " ... install google-chrome from Google repositories ..."
	# needs to be installed before add google key below
	_PACKAGE="gnupg"
	echoinfo "install package: $_PACKAGE ............................. wait ..."
	apt-get install -y -qq --no-install-recommends $_PACKAGE
# install google-chrome
	__net_status google.com
	wget --no-check-certificate -qO- https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add -
	#add-apt-repository 'deb http://dl.google.com/linux/chrome/deb/ stable main'
	_GGL_REPO="deb http://dl.google.com/linux/chrome/deb/ stable main"
	_SRC_FILE="/etc/apt/sources.list"
	if grep -x -q "$_GGL_REPO" $_SRC_FILE; then
			echoinfo "$_GGL_REPO exists..."
		else
			echo $_GGL_REPO >> $_SRC_FILE
	fi
	apt update
	_PACKAGE="google-chrome-stable"
	echoinfo "install package: $_PACKAGE ............................. wait ..."
	apt-get install -y -qq --no-install-recommends $_PACKAGE
	echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __install_stuff4 --------------------------------------------------------------------
## |    Description: install vncserver and vncviewer                                                |
## |         Option:                                                                                  |
## |       Examples:                                                                                  |
## ----------------------------------------------------------------------------------------------------
# loks like tigervnc is best
__install_stuff4 () {
	echofunc "${FUNCNAME[0]}"
	echoinfo " ... install vncserver and viewer ..."
declare -a stuff4=(
	"vnc4server"
	"tigervnc-viewer"
	"tigervnc-common"
)

for _PACKAGE in ${stuff4[@]}; do
	echoinfo "install package: $_PACKAGE . . . . . . . . . . wait . . ."
	apt-get install -y -qq --no-install-recommends $_PACKAGE
done

# create vncserver script and service
cat > /home/$_USER/.vncserver  << 'EOF'
#!/bin/bash
PATH="$PATH:/usr/bin/"
DISPLAY="98"
DEPTH="16"
GEOMETRY="800x600"
NAME="vncserver"

while getopts ':d: :g:' opt
do
  case "${opt}" in
    d ) DISPLAY="$OPTARG"
    ;;
    g ) GEOMETRY="$OPTARG"
    ;;
  esac
done
shift $((OPTIND-1))

OPTIONS="-depth ${DEPTH} -geometry ${GEOMETRY} :${DISPLAY} -name ${NAME} -alwaysshared"
#OPTIONS=":${DISPLAY} -name ${NAME} -alwaysshared"

case "$1" in
	start)
#		/opt/TurboVNC/bin/vncserver ${OPTIONS}
		/usr/bin/vncserver ${OPTIONS}
	;;
	stop)
#		/opt/TurboVNC/bin/vncserver -kill :${DISPLAY}
		/usr/bin/vncserver -kill :${DISPLAY}
	;;
	restart)
		$0 stop
		$0 start
	;;
esac
exit 0
EOF
chmod +x /home/$_USER/.vncserver
chown $_USER:$_USER /home/$_USER/.vncserver

cat > /etc/systemd/system/vncserver.service << EOF
# Contents of /etc/systemd/system/vncserver.service
# generated by $_SCRIPT_FULL_NAME
[Unit]
Description=Manage VNC Server executed by $_USER

[Service]
Type=forking
ExecStart=/home/$_USER/.vncserver start
ExecStop=/home/$_USER/.vncserver stop
ExecReload=/home/$_USER/.vncserver restart
User=$_USER

[Install]
WantedBy=multi-user.target
EOF
systemctl daemon-reload
systemctl enable vncserver.service
echoinfo "service \"vncserver.service\" created, usage: service vncserver start|stop"
echowarning "vncserver.service is enabled, will started after reboot"
# set password for vncserver
rm /home/$_USER/.vnc/passwd 2>/dev/null
_PASSWD="busy4me"
mkdir /home/$_USER/.vnc
echo $_PASSWD | vncpasswd -f > /home/$_USER/.vnc/passwd
chown -R $_USER:$_USER /home/$_USER/.vnc
chmod 600 /home/$_USER/.vnc/passwd
# start vncserver without vncconfig
sed -i 's/vncconfig/#vncconfig/g' /etc/X11/Xvnc-session
}

## -- Function -- __install_init-1 --------------------------------------------------------------------
## |    Description: download and install busy4me in /opt                                             |
## |         Option:                                                                                  |
## |       Examples:                                                                                  |
## ----------------------------------------------------------------------------------------------------
__install_init-1 () {
	echofunc "${FUNCNAME[0]}"
	echoinfo " ... download and install busy4me in /opt ..."
	_FILE="init-1"
	__net_status $_SERVER
	if wget -q -nv -O /usr/bin/$_FILE --no-check-certificate $_SERVER/$_FILE; then
cat > /home/$_USER/.xinitrc  << 'EOF'
openbox-session
EOF
		chown $_USER:$_USER /home/$_USER/.xinitrc
		systemctl set-default multi-user.target
		/usr/bin/initiv show '..in..progress...wait...' &
		bash /usr/bin/$_FILE
	else
		echowarning "no $_FILE..."
	fi
	echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __parted ----------------------------------------------------------------------------
## |    Description: extend linux partition to 10GB (default) on /dev/sda1                            |
## |          Usage: /usr/bin/initiv mb=2000MB parted; expand to 2GB, default part: _DEV=/dev/sda _PART=1    |
## |                 /usr/bin/initiv parted /dev/sda 1 apply                                                 |
## |                 /usr/bin/initiv [mb=] parted [device] [partition] [apply]                               |
## ----------------------------------------------------------------------------------------------------
__parted () {
	[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
	echofunc ${FUNCNAME[0]}
	_PACK=$(apt list parted)
if [[ $_PACK == *"installed"* ]]; then
	echo "parted exists.."
else
	echoinfo "install parted package ....  "
	apt-get install -y -qq --no-install-recommends parted
fi
echoconfirm "disk usage:"
df -h
[[ -z $_DEV ]] && _DEV=/dev/sda
[[ -z $_PART ]] && _PART=1
[[ -z $_APPLY ]] && _APPLY=apply
[[ -z $_EXT ]] && _EXT="1100000MB" # extend to size: 10GB

echoinfo "_DEV=$_DEV; _PART=$_PART; _APPLY=$_APPLY; _EXT=$_EXT"
_USAGE="eg. preview usage: initiv parted /dev/sda 1; apply usage: initiv parted /dev/sda 1 apply"
if [ -z "$_DEV" ]; then
	echowarning "_DEV and _PART are empty... "; echoinfo "$_USAGE"; exit 0
fi
if [ -z "$_PART" ]; then
	echowarning "_PART is empty... "; echoinfo "$_USAGE"; exit 0
fi
fdisk -l $_DEV$_PART >> /dev/null 2>&1 || (echo "could not find $_DEV$_PART - please check" && exit 1)

CURRENTSIZEB=`/sbin/fdisk -l $_DEV$_PART | grep "Disk $_DEV$_PART" | cut -d' ' -f5`
CURRENTSIZE=`expr $CURRENTSIZEB / 1024 / 1024`
#_EXT=`printf %s\\n 'unit MB print list' | parted | grep "Disk ${_DEV}" | cut -d' ' -f3 | tr -d MB`
echowarning "[ok] would/will resize to from ${CURRENTSIZE}MB to ${_EXT}"

if [[ "$_APPLY" == "apply" ]] ; then
  echo "[ok] applying resize operation.."
  /sbin/parted ${_DEV} resizepart ${_PART} yes ${_EXT}
  echoinfo "[done]"
else
  echowarning "Sandbox mode, i did not size!. $_USAGE"
fi
(sleep 1; echoinfo "expand filesystem ........... please wait ..."; exit 0) &
#(sleep 2; printf "\n") &
/sbin/resize2fs $_DEV$_PART 2>/dev/null
echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __tunning ---------------------------------------------------------------------------
## |    Description: tunning                                                                          |
## ----------------------------------------------------------------------------------------------------
__tunning () {
	[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
	echofunc ${FUNCNAME[0]}
	echoinfo "modify /etc/ssh/sshd_config: PermitRootLogin yes"
	sed -i 's/without-password/yes/g' /etc/ssh/sshd_config # deb8
	sed -i 's/\#PermitRootLogin\ prohibit-password/PermitRootLogin\ yes/g' /etc/ssh/sshd_config #deb10
	/sbin/service sshd reload
		echoinfo " ... set /etc/apt/apt.conf: Install-Recommends \"false\""
		rm /etc/apt/apt.conf 2>/dev/null
	echo 'APT::Install-Recommends "false" ; APT::Install-Suggests "false" ;' >> /etc/apt/apt.conf

	############################################
	# grub #####################################
	############################################
	echoinfo " ... configure grub, add options .............."
	_GRUB="/etc/default/grub" # grub config file
	cp $_GRUB $_GRUB-$_DATE_STAMP
	#	sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=0/g' $_GRUB 2>/dev/null
	#	sed -i 's/GRUB_CMDLINE_LINUX_DEFAULT="quiet"/GRUB_CMDLINE_LINUX_DEFAULT="quiet loglevel=0 splash rd.udev.log_priority=3 rd.systemd.show_status=false"/g' $_GRUB 2>/dev/null
	#	sed -i 's/\#GRUB_GFXMODE=640x480/GRUB_GFXMODE=800x600/g' $_GRUB 2>/dev/null
	# make sure there is picture downloaded
	# splash image 640x480, 800x600 etc. works OK,
	__distro
	_SERVER_PATH="$_SERVER/.$_SCRIPT_NAME/$_ID/$_VER/$_ARCH"
	_SPLASH="/usr/share/images/grub/network-globe.tga"
rm $_SPLASH.bak 2>/dev/null
cp $_SPLASH $_SPLASH.bak 2>/dev/null
rm $_SPLASH 2>/dev/null
	if [ ! -f $_SPLASH ]; then
		__net_status $_SERVER
		if ! wget -nv -O $_SPLASH --no-check-certificate $_SERVER_PATH/$_SPLASH; then
			echoerror "there is no file "$_SPLASH" on the server $_SERVER_PATH or no response!..."
			cp $_SPLASH.bak $_SPLASH
		else
			echoconfirm "file "$_SPLASH" downloaded succesfully from server $_SERVER_PATH "
		fi
	fi

# add this to skip fsck: GRUB_CMDLINE_LINUX_DEFAULT="fsck.mode=skip"
cat > $_GRUB <<	EOF
GRUB_DEFAULT=0
GRUB_TIMEOUT=0
GRUB_DISTRIBUTOR="busy4.me"
GRUB_CMDLINE_LINUX_DEFAULT="quiet fsck.mode=skip loglevel=0 splash rd.udev.log_priority=3 rd.systemd.show_status=false"
GRUB_CMDLINE_LINUX=""
GRUB_GFXMODE=800x600
GRUB_GFXPAYLOAD_LINUX=keep
GRUB_BACKGROUND="$_SPLASH"
GRUB_COLOR_NORMAL="black/black"
GRUB_COLOR_HIGHLIGHT="black/black"
COLOR_NORMAL="black/black"
COLOR_HIGHLIGHT="black/black"
EOF
	update-grub 2>/dev/null
	echoconfirm "grub updated OK"

	############################################
	# system options ###########################
	############################################
		echoinfo " ... do not show messages durring boot ........ disable blank console ..."
	sed -i 's/exit 0//g' /etc/rc.local 2>/dev/null
	printf '%s\n%s\n' 'dmesg --console-off' 'exit 0' >> /etc/rc.local
	sed -i 's/#kernel.printk/kernel.printk/g' /etc/sysctl.conf
	if [ -e /etc/default/rcS ];then
		echoinfo " ... modify /etc/default/rcS ..."
		sed -i 's/#VERBOSE/VERBOSE/g' /etc/default/rcS
	else
		echoinfo " ... create /etc/default/rcS file with VERBOSE=no ..."
		touch /etc/default/rcS
		echo 'VERBOSE=no' >> /etc/default/rcS
	fi
	sed -i 's/journal+console/journal/g' /lib/systemd/system/systemd-fsck-root.service
	sed -i 's/journal+console/journal/g' /lib/systemd/system/systemd-fsck@.service

cat > /etc/systemd/journald.conf << EOF
# This file is part of systemd.
# generated by $_SCRIPT_FULL_NAME
[Journal]
Storage=none
ForwardToSyslog=no
ForwardToKMsg=no
ForwardToConsole=no
ForwardToWall=no
MaxLevelStore=emerg
MaxLevelSyslog=emerg
MaxLevelKMsg=emerg
MaxLevelConsole=emerg
MaxLevelWall=emerg
EOF

cat > /etc/systemd/logind.conf << EOF
# This file is part of systemd.
# generated by $_SCRIPT_FULL_NAME
[Login]
NAutoVTs=6
ReserveVT=6
EOF

cat > /etc/systemd/system.conf << EOF
# This file is part of systemd.
# generated by $_SCRIPT_FULL_NAME
[Manager]
LogLevel=emerg
LogTarget=null
#LogColor=yes
#LogLocation=no
DumpCore=no
ShowStatus=no
#CrashChangeVT=no
#CrashShell=no
CrashReboot=yes
DefaultStandardOutput=null
DefaultStandardError=null
DefaultTimeoutStartSec=10s
DefaultTimeoutStopSec=10s
DefaultRestartSec=100ms
DefaultStartLimitIntervalSec=10s
DefaultStartLimitBurst=3
EOF

cat > /etc/systemd/user.conf << EOF
# This file is part of systemd.
# generated by $_SCRIPT_FULL_NAME
[Manager]
LogLevel=emerg
LogTarget=null
#LogColor=yes
#LogLocation=no
ShowStatus=no
#CrashChangeVT=no
#CrashShell=no
CrashReboot=yes
DefaultStandardOutput=null
DefaultStandardError=null
DefaultTimeoutStartSec=10s
DefaultTimeoutStopSec=10s
DefaultRestartSec=100ms
DefaultStartLimitIntervalSec=10s
DefaultStartLimitBurst=3
EOF

cat > /etc/systemd/logind.conf << EOF
# This file is part of systemd.
# generated by $_SCRIPT_FULL_NAME
[Login]
NAutoVTs=5
ReserveVT=5
EOF
echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __remove_dirs -----------------------------------------------------------------------
## |    Description: remove directories                                                               |
## ----------------------------------------------------------------------------------------------------
__remove_dirs () {
	echofunc "${FUNCNAME[0]}"
	echoinfo "remove directories ..."
	if [ $_DIR == "NULL" ]; then
		echoerror "nothing to remove ... add argument please"
	exit 0
	fi
	echowarning "remove $_DIR"
	rm -R $_DIR 2>/dev/null
}

## -- Function -- __remove_files ----------------------------------------------------------------------
## |    Description: remove files                                                                     |
## ----------------------------------------------------------------------------------------------------
##
__remove_files () {
	[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
	echofunc ${FUNCNAME[0]}
	echoinfo "rm /var/cache/apt/*.bin"
rm /var/cache/apt/*.bin 2>/dev/null
	echoinfo "rm /var/cache/debconf/*"
rm /var/cache/debconf/* 2>/dev/null
	echoinfo "rm /var/cache/apt/archives/*.deb"
rm /var/cache/apt/archives/*.deb 2>/dev/null
	echoinfo "rm /var/lib/apt/lists/*.*"
rm /var/lib/apt/lists/*.* 2>/dev/null
	echoinfo "rm -rf /usr/share/man/??"
rm -rf /usr/share/man/?? && rm -rf /usr/share/man/??_*
# rm -rf /usr/lib/modules/4.19.0-8-amd64/kernel/sound/pci/*
# remove all modules, linux starts fine after that :)
echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __download_files --------------------------------------------------------------------
## |    Description: download files                                                                   |
## ----------------------------------------------------------------------------------------------------
## |
__download_files () {
	# download file "package.tar.gz" and unpack to "archive" directory in declared "/full/path/package"
	# help = usage ========================
	# /usr/bin/initiv -d /full/path/package.tar.gz
	# all files from package.tar.gz will be extracted to "/full/path/package" directory
	#	__file=$__file
	[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
	echofunc ${FUNCNAME[0]}

	__distro # check distro

	echoinfo "server distribution path: $_SERVER/.$_SCRIPT_NAME/$_ID/$_VER/$_ARCH"
	_SERVER_PATH="$_SERVER/.$_SCRIPT_NAME/$_ID/$_VER/$_ARCH"
	# help = usage ============================
	# /usr/bin/initiv download
	# will download all files from declared default list
	# declare list of full names of files with full paths
	if [ -z "$__file" ]; then
		echoinfo "declare list of files ......... wait ..."
		declare -a __files=(
	#	"/usr/lib/modules/$_KERNEL_RELEASE.tar.gz" \
		"/usr/share/pixmaps/spin/spin.tar.gz"\
		"/usr/share/pixmaps/dots-mouse/dots-mouse.tar.gz"\
		"/usr/share/pixmaps/red-dots-black/red-dots-black.tar.gz"\
		"/usr/share/pixmaps/busy4me-black/busy4me-black.tar.gz"\
		)
	else
		echoinfo "full file name with path $__file"
		__f=$(echo "${__file##*/}") # extract file name without path
		__p=$(echo "${__file%/*}") # extract path only
		echoinfo "file: $__f"
		echoinfo "path: $__p"
		echoinfo "download file: $__p/$__f ... wait ..."
		rm -R $__p 2>/dev/null# delete old package files and directory
		mkdir $__p
		__net_status $_SERVER
		wget -nv -O $__file --no-check-certificate $_SERVER_PATH/$__path/$__file
		tar -C $__p -zxf $__file
		rm -R $__file 2>/dev/null # clean up
		echoinfo "tar -C $__p -zxvf $__file"; echoinfo "... done"
	fi
	# __filex=$(echo $__file | sed 's/.*\//') # extract file without path
	# __file_path=$(echo $__file | sed 's/$__filex//g') # extract path only, not working with variable
	# easy way:
	# __file=$(echo "${__file##*/}") # extract file name without path
	# __path=$(echo "${__file%/*}") # extract path only
	# source: https://stackoverflow.com/questions/4168371/how-can-i-remove-all-text-after-a-character-in-bash
	# create archive
	# tar -zcvf spin.tar.gz /usr/bin/spin
	# tar -zcvf $_KERNEL_RELEASE.tar.gz /usr/lib/modules/$_KERNEL_RELEASE
	# download file:
	for __file in ${__files[@]}; do
		__f=$(echo "${__file##*/}") # file name without path
		__p=$(echo "${__file%/*}") # path only
		echoinfo "file: $__f"
		echoinfo "path: $__p"
		echoinfo "download file: $__file .......... wait ..."
		rm -R $__p 2>/dev/null # delete old package files and directory
		mkdir $__p
		__net_status $_SERVER
		wget -nv -O $__file --no-check-certificate $_SERVER/.initiv/$_ID/$_VER/$_ARCH/$__path/$__file
		# unpack archive
		tar -C $__p -zxf $__file
		rm -R $__file # clean up
		echoinfo "tar -C $__p -zxvf $__file"
		echoinfo "... done"
		done

	echoinfo "download system files .......................... wait ..."
	###############################################################
	# update root, user, system preferences #######################
	###############################################################
	declare -a _FILES=(
	"/root/.bashrc"
	"/root/.bash_aliases"
	"/home/$_USER/.bashrc"
	"/home/$_USER/.bash_aliases"
	)
	for _FILE in ${_FILES[@]}; do
		rm $_FILE
		echoinfo "download file: $_FILE .......... wait ..."
		__net_status $_SERVER
		wget -nv -O $_FILE --no-check-certificate $_SERVER$_SERVER_DIR$_FILE
	done
	echoconfirm "${FUNCNAME[0]} done"
}

__service () { #help: create service
	echofunc "${FUNCNAME[0]}"
# default services:
# "busy-splash-redblack"
# "busy"
echowarning "default splash service '$_BUSY_ANIME_SERVICE'"

	systemctl disable ${_BUSY_ANIME_SERVICE}.service 2>/dev/null
	systemctl disable ${_BUSY_SERVICE}.service 2>/dev/null
	systemctl disable ${_INITIV_1_SERVICE}.service 2>/dev/null

	systemctl daemon-reload
	echoinfo "create service which runs after reboot"

if [ -z "$_ANIMEDIR" ]; then
	_ANIMEDIR="/usr/share/pixmaps/busy4me-black"
fi
if [ "$_ANIMEDIR" == "light" ]; then
	_ANIMEDIR="/usr/share/pixmaps/dots-mouse"
fi

############################################
# create _BUSY_SERVICE
############################################
cat > /usr/bin/${_BUSY_SERVICE} << EOF
#!/usr/bin/env bash
# generated by $_SCRIPT_FULL_NAME
LOGFILE=/var/log/busy4me.log
touch \$LOGFILE 2>/dev/null # create logfile
chmod 666 /var/log/busy4me.log
exec &> >(tee -ia \$LOGFILE) # everything to logfile
exec 2>&1
logline() {
    while IFS= read -r line; do
        echo "\$(date +%F' '%T) \${0} - \$line line from busy4me.service" >> \$LOGFILE
    done
}

__change_hostname () {
/usr/bin/initiv __change_hostname
# do not run initiv from service and from .profile at the same time, double update will
# broke initiv
}

__initiv_0 () {
#	/usr/bin/initiv 0
#	/usr/bin/initiv parted
# parted can not be done with parted
	sleep infinity
}

__run () {
	while true; do
		sleep 10
		systemctl is-active --quiet getty@tty2 || echo "tty2 is down! ...start again"
		systemctl is-active --quiet getty@tty2 || systemctl start getty@tty2
		systemctl is-active --quiet getty@tty1 || echo "tty1 is down! ...start again"
		systemctl is-active --quiet getty@tty1 || systemctl start getty@tty1
	done
}

case \$1 in
	start)
#		__change_hostname
		__run
#		__initiv_0
# __initiv_0 runs in tty1, parted function cant be done by service
	;;
	stop)
	_PID=\$(pgrep ${_BUSY_SERVICE} | awk '{print \$1}') | logline
	kill -9 \$_PID | logline
	;;
esac
EOF
chmod +x /usr/bin/${_BUSY_SERVICE}
cat > /etc/systemd/system/${_BUSY_SERVICE}.service << EOF
# Contents of /etc/systemd/system/${_BUSY_ANIME_SERVICE}.service
# generated by $_SCRIPT_FULL_NAME
[Unit]
Description=busy4me service
Requires=network-online.target

[Service]
Type=simple
Restart=always
ExecStart=/usr/bin/$_BUSY_SERVICE start

[Install]
WantedBy=multi-user.target
EOF

############################################
# create _BUSY_ANIME_SERVICE service
############################################
cat > /usr/bin/${_BUSY_ANIME_SERVICE} << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME
echo "_ANIMEDIR:$_ANIMEDIR"
_ANIMEDIR='$_ANIMEDIR'



__anime () {
	INT=0 # start from file splash00.jpg
while true; do
	# __anime_fb reads how many lines in busy4me.log and do some animation...
	_L1=\$(wc -l /var/log/busy4me.log | sed 's/\\/var\\/log\\/busy4me.log//g' | tr -d '\n' | sed 's/[[:space:]]//g')
	if [ -z \$_L2 ]; then
		_L2=\$_L1
	fi
	_DIFF=\$(( \$_L2 - \$_L1 + 1 ))
	_ANIMEDIR="/usr/share/pixmaps/busy4me-black"
	if [ \$_DIFF -lt 7 ]; then
		echo "_L1=\$_L1 _L2=\$_L2 _DIFF=\$_DIFF"
		it=\$(awk "BEGIN {print (1/\$_DIFF)}")
		echo "interval it=\$it"
		while [ \$_DIFF -gt 0 ]; do
			[[ \$INT -gt 5 ]] && INT=0
			fbi -d /dev/fb0 -T 1 -noverbose $_ANIMEDIR/splash0\$INT.jpg
			INT=\$(( \$INT +1 ))
			sleep \$it
			_DIFF=\$(( \$_DIFF - 1 ))
			fbi -d /dev/fb0 -T 1 -noverbose $_ANIMEDIR/splash0\$INT.jpg
			INT=\$(( \$INT +1 ))
			sleep \$it
			_DIFF=\$(( \$_DIFF - 1 ))
		done
		pkill fbi
	fi
	if [ \$_DIFF -ge 7 ]; then
		it="0.1" # interval time
		__dirlist=(\`ls \$_ANIMEDIR/\$*\`)
			for __file in \${__dirlist[*]}; do
				fbi -d /dev/fb0 -T 1 -noverbose $_ANIMEDIR/\$__file
				sleep \$it
				pkill fbi
			done
	fi
	_L2=\$(wc -l /var/log/busy4me.log | sed 's/\\/var\\/log\\/busy4me.log//g' | tr -d '\n' | sed 's/[[:space:]]//g')
done



#it="0.05" # interval time
#__dirlist=(\`ls \$_ANIMEDIR/\$*\`)
#while true; do
#	echo "next files from:" \$_ANIMEDIR
#	for __file in \${__dirlist[*]}; do
#			fbi -d /dev/fb0 -T 1 -noverbose $_ANIMEDIR/\$__file
#			sleep \$it
#			fbi -d /dev/fb0 -T 1 -noverbose $_ANIMEDIR/\$__file
#			sleep \$it
#		pkill fbi
#	done
#	echo "stop fbi"
#	pkill fbi
#	sleep 0.5
#done
}

case \$1 in
	start)
	__anime
	;;
	stop)
	_PID=\$(pgrep ${_BUSY_ANIME_SERVICE} | awk '{print \$1}')
	kill -9 \$_PID
#	pkill ${_BUSY_ANIME_SERVICE}
	;;
esac
EOF
chmod +x /usr/bin/${_BUSY_ANIME_SERVICE}

cat > /etc/systemd/system/${_BUSY_ANIME_SERVICE}.service << EOF
# Contents of /etc/systemd/system/${_BUSY_ANIME_SERVICE}.service
# generated by $_SCRIPT_FULL_NAME
[Unit]
Description=redblack - animated splash screen it tty1
Before=network.target

[Service]
Type=simple
Restart=always
ExecStart=/usr/bin/$_BUSY_ANIME_SERVICE start >>/dev/null 2>>/dev/null

[Install]
WantedBy=multi-user.target
EOF

############################################
# create _INITIV_1_SERVICE service
############################################
cat > /usr/bin/${_INITIV_1_SERVICE} << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME

__check_osd () {
_PROC="xt.sh" # looking for process
_CHECK=\$(ps -e | grep \$_PROC | grep -v grep)
while [[ ! \$_CHECK == *\$_PROC* ]]; do
	_CHECK=\$(ps -e | grep \$_PROC | grep -v grep)
	echo "there is no process \$_PROC? check: \$_CHECK ... wait"
	sleep 5
done
echowarning "process \$_PROC running! check: \$_CHECK"
echo ":~# ps -e | grep \$_PROC | grep -v grep"
ps -e | grep \$_PROC | grep -v grep
if [[ \$_CHECK == *\$_PROC* ]]; then
	/usr/bin/initiv show 'PREPARED!...wait...' &
	sleep 5
	/usr/bin/initiv -S 1
	sleep 1200 # wait 20 min, should be finished by this time
fi
echoconfirm "\${FUNCNAME[0]} done, run reset ..."
}
case \$1 in
	start)
	__check_osd
	;;
	stop)
	_PID=\$(pgrep ${_INITIV_1_SERVICE} | awk '{print \$1}')
	kill -9 \$_PID
	;;
esac
EOF
chmod +x /usr/bin/${_INITIV_1_SERVICE}

cat > /etc/systemd/system/${_INITIV_1_SERVICE}.service << EOF
# Contents of /etc/systemd/system/${_INITIV_1_SERVICE}.service
# generated by $_SCRIPT_FULL_NAME
[Unit]
Description=start initiv 1 installation when xt.sh is running on the X
Before=network.target

[Service]
Type=simple
Restart=always
ExecStart=/usr/bin/$_INITIV_1_SERVICE start >>/dev/null 2>>/dev/null

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable ${_BUSY_SERVICE}.service
echoinfo "service \"$_BUSY_SERVICE.service\" created, usage: service $_BUSY_SERVICE start|stop"
echowarning "${_BUSY_SERVICE}.service is enabled, will started after reboot"

systemctl enable ${_BUSY_ANIME_SERVICE}.service
echoinfo "service \"$_BUSY_ANIME_SERVICE.service\" created, usage: service $_BUSY_ANIME_SERVICE start|stop"
echowarning "${_BUSY_ANIME_SERVICE}.service is enabled, will started after reboot"

systemctl enable ${_INITIV_1_SERVICE}.service
echoinfo "service \"$_INITIV_1_SERVICE.service\" created, usage: service $_INITIV_1_SERVICE start|stop"
echowarning "${_INITIV_1_SERVICE}.service is enabled, will started after reboot"

cat > /root/.profile  << `EOF`
[[ \$(tty) = /dev/tty2 ]] && \\
(ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sed 's/127.0.0.1//' | tr '\n' ' ')
`EOF`

if [ "$1" == "disable" ]; then
	/sbin/service $_BUSY_ANIME_SERVICE stop
	systemctl disable ${_BUSY_ANIME_SERVICE}.service
	echoconfirm "${_BUSY_ANIME_SERVICE}.service is disabled "
	systemctl daemon-reload
else
	echowarning "${_BUSY_ANIME_SERVICE}.service is enabled "
fi
echoconfirm "${FUNCNAME[0]} done"
}


## cat >> /usr/bin/initivHelp << 'HELP'
## -- Function -- __anime ------------------------------------------------------------------------------------
## |    Description: create animation script (wallpaper durring installation)                                |
## |         Option: -n [type]                                                                               |
## |          Types: dark <default>, light, spin                                                             |
## |       Examples: /usr/bin/initiv -n light # create white background color animation, four color dots     |
## |                 /usr/bin/initiv -n dark # create black background color animation, three red dots       |
## -----------------------------------------------------------------------------------------------------------
__anime () {
	echofunc "${FUNCNAME[0]}"
if [ -z "$_ANIMEDIR" ]; then
	_ANIMEDIR="/usr/share/pixmaps/busy4me-black"
#else
#	case $_ANIMEDIR in
#		"1"|"dark") _ANIMEDIR="/usr/share/pixmaps/busy4me-black"                                                ;;
#		"2"|"light"|"/usr/share/pixmaps/dots-mouse") _ANIMEDIR="/usr/share/pixmaps/dots-mouse"                                                   ;;
#		"3"|"spin") _ANIMEDIR="/usr/share/pixmaps/spin"                                                          ;;
#		*) echowarning "usage: $0 anime [1|dark|2|light|3|spin]"; _ANIMEDIR="/usr/share/pixmaps/busy4me-black"  ;;
#	esac
fi
case $_THEME in
	light) _ANIMEDIR="/usr/share/pixmaps/dots-mouse" ;;
	*) _ANIMEDIR="/usr/share/pixmaps/busy4me-black" ;;
esac
echo $_THEME > /opt/anime.theme
echo $_ANIMEDIR > /opt/anime.dir
# xli based on xloadimage
# pictures default directory
echoinfo "_ANIMEDIR:$_ANIMEDIR"
rm /opt/anime.sh 2>/dev/null
cat > /opt/anime.sh << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME
echo "_ANIMEDIR:$_ANIMEDIR"
_ANIMEDIR='$_ANIMEDIR'
__anime () {
it="0.2" # interval time
__dirlist=(`ls \$_ANIMEDIR/\$*`)
while true; do
	for __file in \${__dirlist[*]}; do
#		export DISPLAY=:0 && eval xloadimage -onroot $_ANIMEDIR/\$__file &
		xloadimage -onroot $_ANIMEDIR/\$__file &
		sleep \$it
		pkill xloadimage
		sleep \$it
	done
	pkill xloadimage
	sleep 2
done
}
case \$1 in
	\$1)
		_ANIMEDIR=\$1
		__anime
	;;
	*)
		echo "no arguments"
	;;
esac
EOF
chmod +x /opt/anime.sh

# set user's autostart, xinitrc
cp /home/$_USER/.xinitrc /home/$_USER/.xinitrc.bak 2>/dev/null
rm /home/$_USER/.xinitrc 2>/dev/null
cat > /home/$_USER/.xinitrc  << EOF
# generated by $_SCRIPT_FULL_NAME
#xclock
/opt/anime.sh &
/opt/xt.sh
#/opt/osd.sh
EOF
chown $_USER:$_USER /home/$_USER/.xinitrc

# anime by framebuffer
cat > /opt/anime.fb << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME
echo "_ANIMEDIR:$_ANIMEDIR"
_ANIMEDIR='$_ANIMEDIR'
__anime () {
it="0.04" # interval time
__dirlist=(`ls \$_ANIMEDIR/\$*`)
while true; do
	echo "next files from:" \$_ANIMEDIR
	for __file in \${__dirlist[*]}; do
			fbi -1 -T 1 -t 2 -noverbose $_ANIMEDIR/\$__file
			sleep \$it
			fbi -1 -T 1 -t 2 -noverbose $_ANIMEDIR/\$__file
			sleep \$it
		pkill fbi
	done
	echo "stop fbi"
	pkill fbi
	sleep 0.5
done
}
__anime
EOF
chmod +x /opt/anime.fb
echoconfirm "${FUNCNAME[0]} done"
}

__anime_fb () {
	echofunc "${FUNCNAME[0]}"

	INT=0 # start from file splash00.jpg
while true; do
	# __anime_fb reads how many lines in busy4me.log and do some animation...
	_L1=$(wc -l /var/log/busy4me.log | sed 's/\/var\/log\/busy4me.log//g' | tr -d '\n' | sed 's/[[:space:]]//g')
	if [ -z $_L2 ]; then
		_L2=$_L1
	fi
	_DIFF=$(( $_L2 - $_L1 + 1 ))
#	[[ -z $1 ]] && _DIFF=1
#	[[ -n $1 ]] && _DIFF=$1
#	_DIFF=2
	_ANIMEDIR="/usr/share/pixmaps/busy4me-black"
	if [ $_DIFF -lt 7 ]; then
		echook "_L1=$_L1 _L2=$_L2 _DIFF=$_DIFF"
		it=$(awk "BEGIN {print (1/$_DIFF)}")
		echoinfo "interval it=$it"
		while [ $_DIFF -gt 0 ]; do
			[[ $INT -gt 5 ]] && INT=0
			fbi -d /dev/fb0 -T 1 -noverbose $_ANIMEDIR/splash0$INT.jpg
			INT=$(( $INT +1 ))
			sleep $it
			_DIFF=$(( $_DIFF - 1 ))
		done
		pkill fbi
	fi
	if [ $_DIFF -ge 7 ]; then
		it="0.1" # interval time
		__dirlist=(`ls $_ANIMEDIR/$*`)
			for __file in ${__dirlist[*]}; do
				fbi -d /dev/fb0 -T 1 -noverbose $_ANIMEDIR/$__file
				sleep $it
				pkill fbi
			done
	fi
	_L2=$(wc -l /var/log/busy4me.log | sed 's/\/var\/log\/busy4me.log//g' | tr -d '\n' | sed 's/[[:space:]]//g')
done
}

## -- Function -- __osd -------------------------------------------------------------------------------
## |    Description: create script to display text during installation                                |
## ----------------------------------------------------------------------------------------------------
__osd () {
	echofunc "${FUNCNAME[0]}"
_FC=orange # font color

if [[ "$_THEME" = "light" ]]; then
	_FC=blue
fi
#rm $HOME/osd
#cat > /opt/osd << 'EOF'
#Loading . . .
#EOF
__it="0.5"
# help==============================
# see fonts list, command: xlsfonts
# default font:
#__fo="-misc-fixed-medium-r-semicondensed--*-*-*-*-c-*-*-*"
rm /opt/osd.sh
cat > /opt/osd.sh << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME
__fo="-misc-fixed-bold-r-normal--18-120-100-100-c-90-iso8859-1"
	touch \$HOME/osd
		while true; do
			declare -a _DOTS=("." ".." "...")
			for __dot in \${_DOTS[@]}; do
				__r=\$((RANDOM%2+1)) # random 1 digit
				echo "installing \$__dot" 2>&1 | tee \$HOME/osd
				/usr/bin/osd_cat -p bottom -o 2 -A center -c $_FC -d \$__r -f \$__fo \$HOME/osd
			done
		done
EOF
chmod +x /opt/osd.sh
echoinfo "/opt/osd.sh ... created"
echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __dots ------------------------------------------------------------------------------
## |    Description: dots                                                                             |
## ----------------------------------------------------------------------------------------------------
__dots () {
	echofunc "${FUNCNAME[0]}"
_TERM=$(tty)
_PROC=$(ps -e | grep "initiv" | grep -v grep)
echoinfo "$_PROC"
(while [[ $_PROC == *"initiv"* ]]; do
	_PROC=$(ps -e | grep "initiv" | grep -v grep)
    printf '.' > $_TERM
    sleep 1
done) &

sleep 5

printf '\n' > $_TERM
(sleep 0.1; pkill initiv) &
echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __xt -----------------------------------------------------------------------------
## |    Description: create xterminal winodows diplayed durring installation                       |
## -------------------------------------------------------------------------------------------------
__xt () {
echofunc "${FUNCNAME[0]}"
# default theme: dark
case $_THEME in
	"light")
		_BG="white"
		_FG="black"
	;;
	"dark"|*)
		_BG="black"
		_FG="grey"
	;;
esac
echo "switch to $_THEME theme, _BG=$_BG, _FG-$_FG"
echo "$_THEME" > /opt/xt.theme # save value in file

# run xterm with scpecific parameters
cat > /opt/xt.sh << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME
__time () {
	declare -a _DOTS=("0." "1.." "2..." "3...." "4....." "5....." "6......." "7........" "8........." "9..........")
	_START=\$(date +%s)
while true; do
	_ELAPSED=\$((\$(date +%s) - \${_START}))
	for _DOT in \${_DOTS[@]}; do
	echo -ne \$(date -ud "@\$_ELAPSED" +'busy4.me %H:%M:%S')"'\${_DOT}\033[0K\r"
	sleep 0.1
	done
done
}

__count () {
	# generate specific output in terminal
	_MS=\$((10 * 100000))
	echo -e -n "\x1b[\x36 q" # change cursor to steady bar
	while true; do
		__c=\$(( __c+1 ))
		echo -ne " \$_MS \033[0K\r \$__c "
		sleep 0.01
		: \$(( _MS-- ))
	done
}

__ip () {
	# generate IP output in terminal
	_IP=\$(ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sed 's/127.0.0.1//' | tr '\n' ' ')
  while [ -z \$_IP ]; do
		_IP=\$(ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sed 's/127.0.0.1//' | tr '\n' ' ')
	sleep 1
	done
	echo "\$_IP"
	sleep infinity
}

__progress () {
	while true; do
		_LINES=\$(wc -l /var/log/busy4me.log | sed 's/\/var\/log\/busy4me.log//g' | tr -d '\n' | sed 's/[[:space:]]//g')
		_MAX=5170
		echo \$(awk -vn=\$_LINES -vz=\$_MAX 'BEGIN{printf("%.2f",n*100/z)}')" %"
		sleep 1
	done
}

__message () {
	_MESSAGE=\${1}
	echo "\${1}" | tr '\n' ' '
	sleep 60
}

__id () {
	_HOSTNAME=\$(cat /etc/hostname)
	echo "\$_HOSTNAME"
	sleep infinity
}

__xterm () {
	__font="-misc-fixed-bold-r-normal--18-120-100-100-c-90-iso8859-1"
# xterm -geometry 30x20+0+0 -uc -bg black -fg grey -fn \$__font -e /opt/count.sh
	xterm -geometry 50x3+10+10 -bw 0 -uc -bg $_BG -fg $_FG -fn \$__font -e '/opt/xt.sh time' &
	xterm -geometry 11x2+320+568 -bw 0 -uc -bg $_BG -fg $_FG -fn \$__font -e '/opt/xt.sh id' &
	xterm -geometry 16x2+440+568 -bw 0 -uc -bg $_BG -fg $_FG -fn \$__font -e '/opt/xt.sh ip' &
	xterm -geometry 17x2+710+568 -bw 0 -uc -bg $_BG -fg $_FG -fn \$__font -e '/opt/xt.sh progress'
}

case \$1 in
	message) __message \${2}   ;;
	time) __time               ;;
	count) __count             ;;
	ip) __ip                   ;;
	id) __id                   ;;
	progress) __progress       ;;
	*) __xterm                 ;;
esac
EOF
chmod +x /opt/xt.sh
echoinfo "/opt/xt.sh ... created"
echoconfirm "${FUNCNAME[0]} done"
}

## -- Function -- __salt ---------------------------------------------------------------------------
## |    Description: install saltstack                                                             |
## -------------------------------------------------------------------------------------------------
## |
__salt () { #help: install salt-minion, UUID used as minion ID if not provided, restart salt-minion service
	[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
	echofunc ${FUNCNAME[0]}
	# scenario:
	# 1. install salt-miniton with ID UUID (client ask server for registration)
	# 2. auto-register on server side (server)
	# 3. auto-register and associate UUID to unique ID in MySQL (server)
	#  Server MySQL, DB: `b4m.nodes`
	#  | node_id   |              node_uuid               |  node_registration  | status |     secret_key     |
	#  | 000001176 | 17221794-e1ef-4adc-8e3a-6dd9860c2350 | 2020-05-05 18:24:01 |    1   |
	#  | 000001177 | 17221794-e1ef-4adc-8e3a-6dd9860c2350 | 2020-05-05 18:24:01 |    1   |
	#  where:
	# ID: Primary Key: Unique ID
	# UUID: not unique?, could be a clone?
	#  RegDate: registratin time
	#  IP last seen ext IP
	#  Status - 1-online, 0-offline
	# 4. save unique ID in sqlite3 (client side), by salt grains?, txt file?
	# 5. display ID on the VA screen
	# 5. install software?
	# 6. User will register ID number in Studio
	# `b4m.key_value`
	#  |         key        |       name        | value |
	#  | va000001176.status | fb-walking-around |  true |
	#  | 000001177 | 17221794-e1ef-4adc-8e3a-6dd9860c2350 | 2020-05-05 18:24:01 |
	# key:
	# ext_ip, int_ip,
	# send UUID to saltmaster server and get unique ID
		# how?
	UUID=$(cat /sys/class/dmi/id/product_uuid) # same as minion_id

	echoinfo " ... install saltstack, _SALT_MASTER=$_SALT_MASTER"
	__install_stuff1 gnupg
	__net_status saltstack.com
wget -O - http://repo.saltstack.com/py3/debian/10/amd64/latest/SALTSTACK-GPG-KEY.pub | apt-key add -
echo "deb http://repo.saltstack.com/py3/debian/10/amd64/latest buster main" >> /etc/apt/sources.list
apt update
apt install -y salt-common salt-minion
	# Drop the master address if passed
[ ! -d "$_SALT_DIR/minion.d" ] && mkdir -p "$_SALT_DIR/minion.d"
echo "master: $_SALT_MASTER" > $_SALT_DIR/minion.d/99-master-address.conf
	# Drop the minion id if passed
[ ! -d "$_SALT_DIR" ] && mkdir -p "$_SALT_DIR"

_SALT_MINION=$(cat /etc/hostname)
if [ -n $_SALT_MINION ]; then
#	echo "$_SALT_MINION" > "$_SALT_DIR/minion_id"
	echoinfo "new salt-minion ID: $_SALT_MINION"
	/sbin/service salt-minion restart
fi

# cp /etc/hostname $_SALT_DIR/minion_id
/sbin/service salt-minion status
echoconfirm "${FUNCNAME[0]} done"
}

__show () {
	echofunc ${FUNCNAME[0]}
	export DISPLAY=:0
	export XAUTHORITY='/home/'$_USER'/.Xauthority'
	_BG=black
	_FG=grey
	__font="-misc-fixed-bold-r-normal--18-120-100-100-c-90-iso8859-1"
	_MESSAGE="$1"
	echoinfo "message in DISPLAY=$DISPLAY $_MESSAGE"
	if [ -n $1 ]; then
		xterm -geometry 60x5+10+36 -bw 0 -uc -bg $_BG -fg red -fn $__font -e '/opt/xt.sh message '$_MESSAGE
		exit 0
	fi
	# install progress in xterm during first interface...
#while true; do
#	xterm -geometry 105x5+1+540 -bw 0 -uc -bg $_BG -fg $_FG -e '/root/initiv removePackages'
#	xterm -geometry 105x5+1+540 -bw 0 -uc -bg $_BG -fg $_FG -e '/root/initiv apt1'
#	xterm -geometry 105x5+1+540 -bw 0 -uc -bg $_BG -fg $_FG -e '/root/initiv tunning'
#done
}

__prepare () {
	echofunc ${FUNCNAME[0]}
cat > /root/.profile  << 'EOF'
[[ $(tty) = /dev/tty2 ]] && /usr/bin/prepare
EOF

_PROC="xt.sh" # looking for process
_CHECK=$(ps -e | grep $_PROC | grep -v grep)
while [[ ! $_CHECK == *$_PROC* ]]; do
	_CHECK=$(ps -e | grep $_PROC | grep -v grep)
	echo "there is no process $_PROC? check: $_CHECK ... wait"
	sleep 5
done
echowarning "process $_PROC running! check: $_CHECK"
echo ":~# ps -e | grep $_PROC | grep -v grep"
ps -e | grep $_PROC | grep -v grep
if [[ $_CHECK == *$_PROC* ]]; then
	/usr/bin/initiv show 'PREPARED! wait...' &
	sleep 5
	/usr/bin/initiv -S 1
fi
echoconfirm "${FUNCNAME[0]} done, run reset ..."
}

__no_option () {
	echofunc ${FUNCNAME[0]}
	echo -e "${lred}Option does not exist :${lyel} -$OPTARG, ${coloroff} type $0 -h for help"
}

__debfoster () {
	echofunc ${FUNCNAME[0]}
	echoinfo "remove packages using debfoster"
	apt -y install debfoster
	debfoster -q
}

__install_x () {
	echofunc ${FUNCNAME[0]}
	echoinfo "install X"
apt-get install -y -V --no-install-recommends xorg
echoconfirm "${FUNCNAME[0]} done"
}

__interface () {
	echofunc ${FUNCNAME[0]}
	__net_status $_SERVER
	echoinfo "set interface ..."
picture="wallpaper.jpg"
	rm /opt/$picture 2>/dev/null
	wget -nv -O /opt/$picture --no-check-certificate $_SERVER/$picture
chmod 777 /opt/$picture
echoconfirm "${FUNCNAME[0]} done"
}

__count () { #help: generate specific output in terminal
	echofunc ${FUNCNAME[0]}
	_MS=$((10 * 100000))
	echo -e -n "\x1b[\x36 q" # change cursor to steady bar
	while true; do
		__c=$(( __c+1 ))
		echo -ne " $_MS \033[0K\r $__c "
		sleep 0.01
		: $(( _MS-- ))
	done
}

__timer () { #help: Generate one line time counter in Hours,Minutes,Second and deciseconds with nice dots
echofunc ${FUNCNAME[0]}
cat > /opt/timer << EOF
#!/bin/bash
declare -a _DOTS=("0." "1.." "2..." "3...." "4....." "5....." "6......." "7........" "8........." "9..........")
_START=\$(date +%s)
while true; do
	_ELAPSED=\$((\$(date +%s) - \${_START}))
	for _DOT in \${_DOTS[@]}; do
		echo -ne \$(date -ud "@\$_ELAPSED" +'Time elapsed: %H hours %M minutes %S seconds')"'\${_DOT}\033[0K\r"
		sleep 0.1
	done
done
EOF
chmod +x /opt/timer
echoinfo "/opt/timer ... created, usege: /opt/timer"

	declare -a _DOTS=("0." "1.." "2..." "3...." "4....." "5....." "6......." "7........" "8........." "9..........")
		_START=$(date +%s)
while true; do
	_ELAPSED=$(($(date +%s) - ${_START}))
	for _DOT in ${_DOTS[@]}; do
		echo -e -n "\x1b[\x36 q" # change cursor to steady bar
		echo -ne $(date -ud "@$_ELAPSED" +'Time elapsed: %H hours %M minutes %S seconds')"'${_DOT}\033[0K\r"
		sleep 0.1
	done
done
}

__timer2 () {
	echofunc ${FUNCNAME[0]}
_START=$(date +%s)
declare -a _DOTS=("0." "1.." "2..." "3...." "4....." "5....." "6......." "7........" "8........." "9..........")
while true; do
	_ELAPSED=$(($(date +%s) - ${_START}))
	if [[ -z ${_ELAPSED} || ${_ELAPSED} -lt 60 ]] ;then
			min=0 ; secs="${_ELAPSED}"
	else
			time_mins=$(echo "scale=2; ${_ELAPSED}/60" | bc)
			min=$(echo ${time_mins} | cut -d'.' -f1)
			secs="0.$(echo ${time_mins} | cut -d'.' -f2)"
			secs=$(echo ${secs}*60|bc|awk '{print int($_ELAPSED+0.5)}')
	fi
	for _DOT in ${_DOTS[@]}; do
		echo -ne "Time elapsed : 0:${min}:${secs}'${_DOT}\033[0K\r"
		sleep 0.1
	done
	#	_MS=0
	#	while [ $_MS -lt 9 ]; do
	#		_MS=$((${_MS} + 1))
	#echo -ne "Time elapsed : 0:${min}:${secs}.${_MS}\033[0K\r"
	#	done
done
}

__version() { #help: show help...
echo -e "\e[95m$0 -- Version $_SCRIPT_VERSION\e[0m"
}

__cron () {
echofunc ${FUNCNAME[0]}
echowarning "hello from crontab ... :)"
}

__help () { #help: show short functions descriptions
[[ $_SHOW == "true" ]] && __output ${FUNCNAME[0]} && return
echofunc ${FUNCNAME[0]}
echoinfo "=== $_SCRIPT_NAME === Ver.$_SCRIPT_VERSION ======== help =============="
  LANG=en_US.UTF_8
	grep -E '^##' "$0" | sed -e 's|##|\||g' | column -s"|" -t
echo -e "\e[32m  =================== help file end ==============\e[0m"
}

__func_help () { #help: show short functions descriptions
echoinfo "=== $_SCRIPT_NAME === Ver.$_SCRIPT_VERSION ======== help =============="
echofunc "${FUNCNAME[0]}"
  LANG=en_US.UTF_8
echoinfo "=== Functions list ==="
  grep -E '^_.+ #help' "$0" | sed -e 's|() { #help: |.|g' | column -s"..." -t | sort
}

__stuff_help () { #help: show short functions descriptions
echofunc "${FUNCNAME[0]}"
  LANG=en_US.UTF_8
echoinfo "=== Stuff list ==="
echoinfo "   *TODO"
}

##
cat > /usr/bin/updated << EOF
## === udpate every time ===========================================================================
## | run automaticaly udate every time on start!
## | try: initiv -k 		to skip update                                                             |
## =================================================================================================
EOF
## __update

##
## === options =====================================================================================
## | pass options with or without parameters                                                       |
## =================================================================================================
## Available options:
##
while getopts ':a: b d: f F h H: i: k l n: N o: r s: S v T: t: u: U: w x X' opt
do
  case "${opt}" in
    a ) _AUTOUSER="$OPTARG"; __autologin; __autostart                                       ;;
## -a <user>	set who will be automaticaly logged in tty1, start X session and execute X apps
		b ) __install_stuff4; exit 0                                                            ;;
## -b		install stuff4 & exit (List of stuff: /usr/bin/initiv -l)
## -c		option "c"
		d ) __file="$OPTARG"; __download_files; exit 0                                          ;;
## -d <file>	download specific file, eg,: initiv -d file.txt
## -e		option "e"
		f ) [[ -n $2 ]] && $2;  __func_help                                                     ;;
## -f		show all functions short descriptions
## -f <function>	execute specific function!
		F ) __fix                                                                               ;;
## -F	fix possible problems with filesystem, databeses, apt, dpkg etc
## 		examples: /usr/bin/initiv -f __timer	# execute __timer function
## -g		option "g"
    h|\? ) __help; exit 0                                                                   ;;
## -h	or -?	this help
		H ) _THEME="$OPTARG"; _ANIMEDIR="$OPTARG"; __anime; __xt; __osd                ;;
## -H <value>	Pass the loading theme. values: <light> or <dark> (default)
		i ) _PACKAGE="$OPTARG"; __install                                                       ;;
## -i <package>	Install particular package, could be defined short name, eg. initiv -p ssh
## 		available short names: ssh (install openssh-server)
##
## -j		option "j"
		k ) _SKIP_UPDATE="true"                                                                 ;;
## -k		skip auto update *TODO
		l ) __stuff_help                                                                        ;;
## -l		Stuff list *TODO
## -m		option "m"
		n )  _ANIMEDIR="$OPTARG"; echoinfo "_ANIMEDIR=$OPTARG"                                  ;;
## -n <dir)	Set background animation, where <dir> contains pictures for animation *TODO
		N ) _SKIP_NET="true"                                                                 ;;
## -N	skip __net_status check
		r ) __reset; exit 0                                                                     ;;
## -r reset ttyX consoles
		s ) _SALT_MASTER="$OPTARG"                                                              ;;
## -s <server>	set salt-master server IP address or DNS name (default: saltmaster.localhost)
## 		stored in ${_SALT_DIR}/minion.d/99-master-address.conf
		S ) _SHOW="true"                                                                        ;;
## show execution in xterm, on tty1, user's X session
## use this option if you want see output on DISPLAY:0 instead terminal
		t ) _SALT_MINION="$OPTARG"                                                              ;;
## -t <name>	set salt-minion ID (default: machine UUID)
## 		stored in ${_SALT_DIR}/minion_id
    T ) _NEW_HOSTNAME="$OPTARG"; __change_hostname                                             ;;
## -T <hostname>	pass host name value and execute change hostname -T hostname, -T node (default)
## -q		option "q"
		u ) _UPDATE="$OPTARG"                                                                   ;;
## -u		Update itself (download new version from server and replace the script)
		U ) _USER="$OPTARG"; __useradd; __anime; __autologin; __autostart; __reset              ;;
## -U <username>	Add user to the system, set autologin and autostart, reset xinit(Xorg) in tty1
		v ) __version                                                                           ;;
## -v		Display script version
		w ) __update_apt_repos                                                                  ;;
# -w		update default apt repos
		x ) _XT="YES"; echoinfo "run in the screen DISPLAY :0"                                  ;;
## -x		run command in xterminal (durring the first interface screen)
		X ) __install_x; (sleep 2; __reset) &                                                   ;;
## -X		install X server and reset tty1
## -y		option "y"
## -z		option "z"
		:) echowarning "Option -$OPTARG requires an argument." >&2                              ;;
		* )  __help; exit 0                                                                     ;;
  esac
done
shift $((OPTIND-1))

## ==================================================================================================
## === pre actions befor all actions ================================================================
## | actions executed                                                                               |
## ==================================================================================================
## ==================================================================================================
##
##
if [ ! -e /usr/bin/bashcolors ]; then
	__bashcolor
fi
# __update # prevent double update
# __net_status google.com

## === actions ======================================================================================
## | actions                                                                                        |
## ==================================================================================================
## |
## Available actions:
##
case $1 in
	"update" )	__update                                                                 ;;
## update||update itself
	"updateApt"|"aptUpdate"|"apt" )	__update_apt_repos                                   ;;
## aptUpdate|update apt repos
	"removeFiles"|"remove-files" )	__remove_files                                       ;;
## remove_files - remove unneded files
	"removePackages"|"remove-packages" )	__remove_packages                              ;;
## remove_packages - remove unnided packages
	"autostart"|"autostartSet"|"autostart-set" )	__autostart $2                         ;;
## autostart	set programs tu run in user files: .profile and .xinitrc
	"autologin"|"autologinSet"|"autologin-set" )	__autologin $2                         ;;
## autologin	set who will be logged in tty1
	"tunning" )	__tunning                                                                ;;
## tunning	visual cosmetic tunning
	"installStuff1"|"install-stuff1"|"apt1" )	__install_stuff1                           ;;
## apt1	install stuff from apt
	"installStuff2"|"install-stuff2"|"apt2" )	__install_stuff2                           ;;
## apt2	install stuff2 from apt
	"installStuff3"|"install-stuff3"|"apt3" )	__install_stuff3                           ;;
## apt3	install stuff3 from apt
	"salt" ) __salt                                                                      ;;
## salt - install salt minion
	"installX"|"install-x"|"X")	__install_x                                                ;;
## installX	install Xorg server
	"interface" )	__interface                                                            ;;
	"download" )	__download_files                                                       ;;
	"anime"|"spin"|"animation" )	_ANIMEDIR="$2"; __download_files; __anime              ;;
	"osd" )	__osd                                                                        ;;
	"reset" )	__reset                                                                    ;;
## reset	reset xinit (X server) and all child processes in tty1
	"xt" )	__xt                                                                         ;;
## xt	create xt.sh script, executed in first install screen
	"dots" )	__dots                                                                     ;;
	"createRecovery"|"create-recovery" )	__create_recovery                              ;;
	"parted" )	_DEV=$2; _PART=$3; _APPLY=$4; __parted                                   ;;
## parted	expand partition to default 10GB
	"busy" )	__install_stuff4                                                           ;;
## busy	install stuff4, download and execute script init-1
	"timer" )	__timer                                                                    ;;
## timer	show timer test
	"cron" )	__cron                                                                    ;;
## timer	show timer test
	"show" )	__show $2                                                                  ;;
## show	run xterm small window with installation scripts
	"service" )	__service $2                                                             ;;
## create service
## usage: /usr/bin/initiv service [service-name] - create service witch providead name
## 		/usr/bin/initiv service - withou parameters will craete service "busy" and "busy-flash-redblack"
	"prepare" )	__prepare                                                                ;;
## prepare	set distro to distribution
## - do it on fresh installed distro
	"install" )
		__read_data
		__net_status google.com
		__update # use -k option to skip update
		__remove_packages
		__update_apt_repos
		__install
		__change_hostname
		__tunning
		__service
		__download_files
		__anime dark
		__autologin root
		__autostart root
		__read_data
		/sbin/service $_BUSY_SERVICE start
		systemctl disable $_BUSY_ANIME_SERVICE
		systemctl enable $_BUSY_ANIME_SERVICE
#		sleep 1
		(sleep 1; echo -e "\n\e[32m * READY! \n\
		... installation will start after reboot or reset tty1 console \n\
		type: 'reboot' and hit ENTER to start installation now or\n\
		type: 'halt -p' and hit ENTER to switch machine off.\n\
		V-Assistant machine is ready for distribution.\e[0m")
		echo "$_DATE_STAMP initiv ready" > $_LOGFILE
#		/sbin/service $_BUSY_ANIME_SERVICE start
#		(sleep 10; /usr/bin/initiv reset)
#		(sleep 2; bash --rcfile <(echo '. ~/.bashrc; /usr/bin/initiv reset'))
#		(sleep 1, reboot) &
#		/sbin/service $_BUSY_ANIME_SERVICE start
		;;
## install basic packages for splash and first boot
## - do it automatically just after first run (partiton will be expanded, and VM file will grow)
	"0" )
## 0	execute all initial options, remove packages, set user, install X and basic stuff
##
		__read_data
		__interface
		__net_status # used for waitng for IP from DHCP
		__change_hostname # previously used for waiting for IP from DHCP
		__salt
		__update
		__update_apt_repos
		__install_stuff1
		__useradd
		__parted
		__install_x
		__download_files
		__autologin
		__autostart
		__anime
		__osd
		__xt
		__read_data
		systemctl disable $_BUSY_ANIME_SERVICE
		systemctl stop $_BUSY_ANIME_SERVICE
		/sbin/service $_BUSY_ANIME_SERVICE stop
		/sbin/service $_INITIV_1_SERVICE start
#		(sleep 2; __prepare) &
		echo "... reset in 5s"
		sleep 5
		(sleep 2; /usr/bin/initiv reset)
		;;
	"1" )
## 1	execute installation process just after download and first X run by user
		__fix
		__change_hostname
		__install_stuff2
		__install_stuff3
		__install_stuff4
		__install_init-1
		systemctl disable $_BUSY_SERVICE
		(sleep 2; systemctl disable $_INITIV_1_SERVICE)
		(sleep 4; systemctl stop $_INITIV_1_SERVICE)
		(sleep 6; /sbin/service $_INITIV_1_SERVICE stop)
		(sleep 8; systemctl reboot now)
#		__reset
		;;
	"2" )
## 2	download and run init-1 script which next install busy4.me package and reboot
		__install_init-1
		;;
	"$1")
	$1 $2 2>/dev/null
	if [ ! $? == "0" ]; then
		echoerror "$1 - command not found, try $0 --help"
	fi
	;;
	*)
	 	__help
		;;
esac
##
## Examples:
## /usr/bin/initiv -U baltazar	#create user "baltasar", set autologin and autostart, reset tty1
## /usr/bin/initiv 0		#virgin init on fresh distro, remove packages, tunning, install stuff,
##			prepare 1st interface)
## /usr/bin/initiv 1		#install stuff just after 1st run in VM, download /usr/bin/inti-1 (install busy4me in /opt)
## /usr/bin/initiv 2		#
## /usr/bin/initiv -u		#update itself
## /usr/bin/initiv -S apt	#show apt update in the screen :0
## /usr/bin/initiv -S apt1	#show suff1 installation in the screen :0
## /usr/bin/initiv -S __download_files	#show files download process in the screen :0
## /usr/bin/initiv prepare	#set to run all intallation process after next reboot, use it when you want prepare
##		and distribute. CAUNTION! after next run, partition will be expanded and the filesystem will
##		grow a lot when all stuff will be installed
## /usr/bin/initiv -S 1	CAUTION! install all stuff
## /usr/bin/initiv -a user1 -n light -A "master.hipposite.com" install
##
## /usr/bin/initiv -s '192.168.1.30' -t 'saltminionID' salt
##		install saltstack with salt-master and salt-minion defined
##
##
[[ -f /usr/bin/initivRecovery ]] ||	{ echoinfo "create script initivRecovery ... "; __create_recovery; }

echo -e $coloroff
echook "END of script"
secs_to_human "$(($(date +%s) - ${_START}))"
exit 0
#
