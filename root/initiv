#!/bin/bash
# Slimming Linux bootstrap script, Author: Visaroy <visaroy@gmail.com>
# used to slim Linux distributions, remove unnecessary things, packages, files, dirs, manuals, logs, etc.
# The main goals are: save a lot of space on root filesystem and prepare distro for specific tasks.
# Install only the packages you need, eg. when you need web browser xorg+firefox you do not need vim
# Comments with double ## are in help option -h or --help
# try: ./initiv -h
## * Usage: ./initiv [-o]... [parameter]... <action>
## where -o is option with or without parameter
##
# Everything below will go to the file 'initiv.log':
exec &> >(tee -ia initiv.log)
exec 2>&1

_START=$(date +%s) # calculate how long script runs (see on the end)
_SCRIPT_PATH=`pwd`
_SCRIPT_NAME="initiv"
_SCRIPT_VERSION="20.02"
_SCRIPT_FULL_NAME="$0"
_SCRIPT_ARGUMENTS="$*"
_DATE_STAMP="$(date +%Y-%m-%d--%H-%M-%S)"
_SERVER="http://busy4.me"
_USER="busyman" # default user name
#_PASS="busy" # default user password
_THEME=dark # default installation theme, used in __xt and __anime functions
_BG=black # default background color, used by xterm option -bg
_FG=grey # default foreground color, used by xterm option -fg
_SALT_DIR="/etc/salt"
_SALT_MASTER="192.168.121.250"
_SALT_MINION=$(cat /sys/class/dmi/id/product_uuid)

# set bashcolors ===============================================================
if ! wget -q -nv -O ./bashcolors --no-check-certificate $_SERVER/bashcolors; then
	echo -e "no colors...\e[0m"
else
. ./bashcolors
echo -e "${lblu}o${gre}o${cya}o${red}o${mag}o${yel}o${gre}o${lbla}o${lblu}o${gre}o${cya}o${red}\
o${mag}o${yel}o${whi}o${lbla}o${whi}o${yel}o${mag}o${red}o${cya}o${gre}o${lblu}o${lbla}o${gre}\
o${yel}o${mag}o${red}o${cya}o${gre}o${lblu}o
_SCRIPT_ARGUMENTS=$_SCRIPT_ARGUMENTS ${coloroff}"
fi

__fix () { #help: fix possible problems with filesystem, databeses, apt, dpkg etc.
echofunc ${FUNCNAME[0]}
/usr/share/debconf/fix_db.pl # avoid problem with debconf corruption
update-default-wordlist
dpkg --configure -a # if dpkg was interrupted, correct the problem.
dpkg-reconfigure -u dictionaries-common
}

## -- Function -- __autologin -------------------------------------------------------------------------
## |    Description: Add user and set password (default user: busyman without password)               |
## |         Option: -U [user]                                                                        |
## |        Caution: AFTER CREATE USER THE CONSOLE tty1 WILL BE RESTARTED IMMEDIATELY and NEW USER    |
## |                 WILL START WORK IN NEW X SESSION                                                 |
## |           user: user's name                                                                      |
## |       Examples: ./initiv -U kate # create user "kate" and allow use crontab                      |
##----------------------------------------------------------------------------------------------------
__useradd () { #help: add user
	echofunc "__useradd"
	echoinfo "_USER=$_USER"
	/usr/sbin/groupadd $_USER 2>/dev/null
	/usr/sbin/useradd -r -s /bin/bash -m -g $_USER $_USER 2>/dev/null
#	useradd -p $(openssl passwd -1 $_PASS) -r -s /bin/bash -m -g $_USER $_USER 2>/dev/null
	/usr/sbin/usermod -a -G "cdrom,floppy,dip,plugdev,netdev,audio,video" $_USER
	_CAF="/etc/cron.allow" # Cron Allow File
if ! grep -q $_USER $_CAF; then
	echo "$_USER" >> $_CAF
	echoconfirm "$_USER added to $_CAF"
else
	echoinfo "$_USER already exists in $_CAF"
fi
}

## -- Function -- __autologin -------------------------------------------------------------------------
## |    Description: Autologin as $_USER user without login manager in console tty1...                |
## |         Option: -a [user]                                                                        |
## |           user: existing user name                                                               |
## |       Examples: ./initiv -a kate # set "kate" user automaticaly logged in tty1                   |
## ----------------------------------------------------------------------------------------------------
##
__autologin () { #help: set autologin, who will be automaticaly logged in tty1
echofunc "__autologin"
echoinfo "_AUTOUSER=$_USER"
# autologin as $busyuser in tty1
_AUTOUSER=$_USER
#if [ "$_AUTOUSER" != "" ]; then
#		_USER=$_AUTOUSER
#fi
echo -e "\e[32m Autologin as \e[95m$_USER\e[0m user without login manager in console tty1...\e[0m"
mkdir -pv /etc/systemd/system/getty@tty1.service.d 2>/dev/null
rm /etc/systemd/system/getty@tty1.service.d/autologin.conf 2>/dev/null
cat > /etc/systemd/system/getty@tty1.service.d/autologin.conf << EOF
[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin $_AUTOUSER --noclear %I $TERM
EOF

# autologin as root in tty2
#
mkdir -pv /etc/systemd/system/getty@tty2.service.d 2>/dev/null
rm /etc/systemd/system/getty@tty2.service.d/autologin.conf 2>/dev/null
cat > /etc/systemd/system/getty@tty2.service.d/autologin.conf << EOF
[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin root --noclear %I $TERM
EOF
systemctl set-default multi-user.target
}

## -- Function -- __autostart -------------------------------------------------------------------------
## |    Description: set startx after autologing and applications after X starts                      |
## ----------------------------------------------------------------------------------------------------
## |
__autostart () {

	echofunc "__autostart"
	echoinfo "_AUTOUSER=$_USER set startx after autologing and applications after X starts..."
cp /home/$_USER/.profile /home/$_USER/.profile.bak 2>/dev/null
rm /home/$_USER/.profile 2>/dev/null
# [[ $(tty) = /dev/tty1 ]] && setterm -blank 0 -powersave off && startx -- vt1 &> /dev/null
cat > /home/$_USER/.profile  << 'EOF'
[[ $(tty) = /dev/tty1 ]] && setterm -blank 0 -powersave off && startx -- vt1 &> /dev/null
EOF
chown $_USER:$_USER /home/$_USER/.profile

cp /home/$_USER/.xinitrc /home/$_USER/.xinitrc.bak 2>/dev/null
rm /home/$_USER/.xinitrc 2>/dev/null
cat > /home/$_USER/.xinitrc  << 'EOF'
#xclock
/opt/anime.sh &
(sleep 2; /opt/xt.sh) &
/opt/osd.sh
EOF
chown $_USER:$_USER /home/$_USER/.xinitrc
systemctl set-default multi-user.target
}

secs_to_human() {
    if [[ -z ${1} || ${1} -lt 60 ]] ;then
        min=0 ; secs="${1}"
    else
        time_mins=$(echo "scale=2; ${1}/60" | bc)
        min=$(echo ${time_mins} | cut -d'.' -f1)
        secs="0.$(echo ${time_mins} | cut -d'.' -f2)"
        secs=$(echo ${secs}*60|bc|awk '{print int($1+0.5)}')
    fi
    echo "Time Elapsed : ${min} minutes and ${secs} seconds."
}

# set echo types
echoerror() {
    printf "${lred} * ERROR${lred}: %s${nocolor}\\n" "$@" 1>&2;
}

echowarning() {
    printf "${lyel} * WARNING: %s ${nocolor}\\n" "$@" 1>&2;
}

echoinfo() {
    printf "${lblu}   * INFO${lcya}: %s ${nocolor}\\n" "$@" 1>&2;
}

echoconfirm() {
    printf "${mag}   * INFO${lmag}: %s ${nocolor}\\n" "$@" 1>&2;
}

echofunc() {
    printf "${lgre} * FUNCTION${gre}: %s${nocolor}\\n" "$@" 1>&2;
}

if [ $USER != "root" ]; then
	echoinfo "... ### run this script as root to get full functionality ### ..."
fi

## -- Function -- __create_recovery -------------------------------------------------------------------
## |    Description: create initivRecovery file, used in emergency when update goes wrong.            |
## |          Usage: ./initivRecovery                                                                 |
## |                 Script ./initivRecovery removes badly updated ./initiv and copy from last        |
## |                 backup file ./initiv-*                                                           |
## ----------------------------------------------------------------------------------------------------
##
__create_recovery () {
	echofunc "__create_recovery"
# create recovery script 'initiv-recovery', to be using in emergency case, eg.when update went wrong
echoinfo "_SCRIPT_PATH: $_SCRIPT_PATH/initivRecovery"
cat > $_SCRIPT_PATH/initivRecovery  << EOF
#/bin/bash
rm ./initiv
cp ./initiv-* ./initiv
EOF
chmod +x ./initivRecovery
}

# reset (restart) Xserver (xinit) in tty1
## -- Function -- __reset -----------------------------------------------------------------------------
## |    Description: reset xinit and Xserver in default tty1                                          |
## ----------------------------------------------------------------------------------------------------
__reset () {
echofunc "reset ttyX services ... wait"
	service getty@tty1 stop
	(sleep 2; service getty@tty1 restart) &
	service getty@tty2 stop
	(sleep 5; service getty@tty2 restart) &
	echoinfo " ... done"
}

## -- Function -- __add_to_path -----------------------------------------------------------------------
## |    Description: add initiv to path                                                               |
## ----------------------------------------------------------------------------------------------------
__add_to_path () {
	echo "PATH="$PATH
	case "$(echo $PATH)" in
	  *"/root"*)
		echoinfo "PATH contains: $_SCRIPT_PATH"
	  ;;
	  *)
		echowarning "add to path ... "$_SCRIPT_PATH
	  PATH=$PATH:/stratum; export PATH
		sed -i 's/export PATH=$PATH:\/root//g' ~/.profile
	  echo 'export PATH=$PATH:'$_SCRIPT_PATH  >> ~/.profile
	  ;;
	esac
}

__add_to_path

## -- Function -- __read_data -------------------------------------------------------------------------
## |    Description: read data                                                                        |
## ----------------------------------------------------------------------------------------------------
__read_data () {
case $1 in
	"theme")
	_THEME=$(<"/opt/xt.theme")
		echo "read theme: $_THEME"
		case $_THEME in
			"light")
			echo "set _BG _FG for light theme..."
				_BG="white"
				_FG="black"
			;;
			"dark"|*)
			echo "set _BG _FG for dark theme..."
				_BG="black"
				_FG="grey"
			;;
		esac
	;;
esac
echofunc "__read_data"
# rm ./initivData
echo $_DATE_STAMP " - disk usage:" $(df -H | grep -vE 'Filesystem|tmpfs|cdom' | grep /dev/ | awk '{ print $1 " " $3 }') >> ./initivData
_DISK=$(echo $_DATE_STAMP " - disk usage:" $(df -H | grep -vE 'Filesystem|tmpfs|cdom'| grep /dev/ | awk '{ print $1 " " $3 }'))
# | tr '\n' ' '
echoinfo "read disk usage ..." | tr '\n' ' '
echo $_DISK
}

## -- Function -- __remove_packages -------------------------------------------------------------------
## |    Description: remove packages                                                                  |
## ----------------------------------------------------------------------------------------------------
__remove_packages () {
	echofunc "__remove_packages"
# I did try remove: "ispell", but sometimes :/ needs interactive answer, hmmm
# "keyboard-configuration"
	declare -a _PACKAGES=(
	"acpi"
	"acpid"
	"eject"
	"gcc-4.8-base:amd64"
	"os-prober"
	"laptop-detect"
	"manpages"
	"nano"
	"tasksel"
	"traceroute"
	"usbutils"
	"vim-common"
	"vim-tiny"
	"console-setup"
	"discover"
	"installation-report"
	"kbd"
	"xxd"
	"libc-l10n"
	"pciutils"
	"apparmor"
	)
		for _PACKAGE in ${_PACKAGES[@]}; do
			echoinfo "remove package: $_PACKAGE ............................. wait ..."
			apt-get -qq purge $_PACKAGE
		done
	apt-get -qq autoremove
	apt-get clean
}

## -- Function -- __update_apt_repos ------------------------------------------------------------------
## |    Description: update apt                                                                       |
## ----------------------------------------------------------------------------------------------------
__update_apt_repos () {
	__output ${FUNCNAME[0]}
	echofunc ${FUNCNAME[0]}
	cp /etc/apt/sources.list /etc/apt/sources.list.bak; rm /etc/apt/sources.list
		#add main repo Debian 8 Jessie
		#echo 'deb http://ftp.debian.org/debian jessie main' >> /etc/apt/sources.list
#add main repo Debian 10 Buster
cat > /etc/apt/sources.list << EOF
deb http://deb.debian.org/debian buster main
#deb-src http://deb.debian.org/debian buster main
deb http://deb.debian.org/debian-security/ buster/updates main
#deb-src http://deb.debian.org/debian-security/ buster/updates main
deb http://deb.debian.org/debian buster-updates main
#deb-src http://deb.debian.org/debian buster-updates main
EOF
apt update
}

function __output () {
	echofunc ${FUNCNAME[0]}
	_FUNC=$1
	if [[ $_SHOW == "true" ]]; then
		export DISPLAY=:0
		export XAUTHORITY='/home/'$_USER'/.Xauthority'
		echowarning "_SHOW=$_SHOW execute in xterm in DISPLAY=$DISPLAY"
		__read_data theme
		xterm -geometry 105x5+1+530 -bw 0 -uc -bg $_BG -fg $_FG -e "$_SCRIPT_FULL_NAME $_FUNC"
	else
		echoinfo "standard output ..."
	fi
}

## -- Function -- __install ---------------------------------------------------------------------------
## |    Description: install openssh-server, openssl, bc, xloadimage, xli, xosd-bin, parted           |
## ----------------------------------------------------------------------------------------------------
__install () { #help: usege ./initiv -i package or ./initiv __install - to install basic packages
	__output ${FUNCNAME[0]}
	echofunc ${FUNCNAME[0]}
	echoinfo " ... install basic for frepare splash and first boot ..."
# if used short name "ssh" then openssh-server will be installed
# usage: ./initiv -i ssh
#
	[[ "$_PACKAGE" = "ssh" ]] &&	{ \
		echoinfo "install openssh-server..  wait...."; \
		apt-get install -y -qq --no-install-recommends openssh-server; exit 0; }

	if [ -z $1 ]; then
		declare -a stuff=(
		"grub2-splashimages"
		"fbi"
		)
		for _PACKAGE in ${stuff[@]}; do
			echoinfo "install package: $_PACKAGE ............................. wait ..."
			apt-get install -y -qq --no-install-recommends $_PACKAGE
		done
	else
		echo "install $1 ....................."
		apt-get install -y -qq --no-install-recommends $1
	fi
}

## -- Function -- __install_stuff1 --------------------------------------------------------------------
## |    Description: install openssh-server, openssl, bc, xloadimage, xli, xosd-bin, parted           |
## ----------------------------------------------------------------------------------------------------
__install_stuff1 () {
	__output ${FUNCNAME[0]}
	echofunc ${FUNCNAME[0]}
	echoinfo " ... install stuff from official repositories ..."
	if [ -z $1 ]; then
		declare -a stuff=(
		"grub2-splashimages"
		"openssh-server"
		"openssl"
		"bc"
		"xloadimage"
		"xli"
		"xosd-bin"
		"parted"
		)
		for _PACKAGE in ${stuff[@]}; do
			echoinfo "install package: $_PACKAGE ............................. wait ..."
			apt-get install -y -qq --no-install-recommends $_PACKAGE
		done
	fi
}

## -- Function -- __install_stuff2 --------------------------------------------------------------------
## |    Description: install stuff 2                                                                  |
## |         Option: -apt2 |installStuff2                                                             |
## |       Examples: ./initiv -apt2                                                                   |
## ----------------------------------------------------------------------------------------------------
__install_stuff2 () {
	__output ${FUNCNAME[0]}
	echofunc ${FUNCNAME[0]}
	echoinfo " ... install stuff2 from Debian repositories ..."
# install stuff during "installation ..." message
# "software-properties-common" may be not needed
# "nginx" not needed, old idea to use as interactive menu

declare -a stuff2=(
"curl"
"wget"
"openbox"
"xdotool"
"wmctrl"
"netcat"
"xcompmgr"
"feh"
"bc"
"ntp"
"zenity"
"xclip"
"ntpdate"
"scrot"
"screen"
"sqlite3"
"xvfb"
"tint2"
"dbus"
"ffmpeg"
"python"
"python-dev"
"python-tk"
"python-pip"
"python-xlib"
"python-pillow"
)
	for _PACKAGE in ${stuff2[@]}; do
		echoinfo "install package: $_PACKAGE ............................. wait ..."
		apt-get install -y -qq --no-install-recommends $_PACKAGE
	done
pip install setuptools -U # update 08-2019,
pip install pyautogui # need for automate keys, mouse, recognise pictures on the screen
}

## -- Function -- __install_stuff3 --------------------------------------------------------------------
## |    Description: install google chrome                                                            |
## |         Option: -apt3                                                                            |
## |       Examples: ./initiv -apt3                                                                   |
## ----------------------------------------------------------------------------------------------------
__install_stuff3 () {
	__output ${FUNCNAME[0]}
	echofunc ${FUNCNAME[0]}
	echoinfo " ... install stuff3 from other repositories ..."
	# needs to be installed before add google key below
	_PACKAGE="gnupg"
	echoinfo "install package: $_PACKAGE ............................. wait ..."
	apt-get install -y -qq --no-install-recommends $_PACKAGE
# instll google-chrome
	wget --no-check-certificate -qO- https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add -
	#add-apt-repository 'deb http://dl.google.com/linux/chrome/deb/ stable main'
	_GGL_REPO="deb http://dl.google.com/linux/chrome/deb/ stable main"
	_SRC_FILE="/etc/apt/sources.list"
	if grep -x -q "$_GGL_REPO" $_SRC_FILE; then
			echoinfo "$_GGL_REPO exists..."
		else
			echo $_GGL_REPO >> $_SRC_FILE
	fi
	apt update
	_PACKAGE="google-chrome-stable"
	echoinfo "install package: $_PACKAGE ............................. wait ..."
	apt-get install -y -qq --no-install-recommends $_PACKAGE
}

## -- Function -- __install_stuff4 --------------------------------------------------------------------
## |    Description: download and install busy4me in /opt                                             |
## |         Option:                                                                                  |
## |       Examples:                                                                                  |
## ----------------------------------------------------------------------------------------------------
__install_stuff4 () {
	echofunc "__install_stuff4"
	echoinfo " ... download and install busy4me in /opt ..."
	_FILE="init-1"
	if wget -q -nv -O ./$_FILE --no-check-certificate $_SERVER/$_FILE; then
cat > /home/$_USER/.xinitrc  << 'EOF'
openbox-session
EOF
		chown $_USER:$_USER /home/$_USER/.xinitrc
		systemctl set-default multi-user.target
		bash ./$_FILE
	else
		echowarning "no $_FILE..."
	fi
}

## -- Function -- __parted ----------------------------------------------------------------------------
## |    Description: extend linux partition to 10GB (default) on /dev/sda1                            |
## |          Usage: ./initiv mb=2000MB parted; expand to 2GB, default part: _DEV=/dev/sda _PART=1    |
## |                 ./initiv parted /dev/sda 1 apply                                                 |
## |                 ./initiv [mb=] parted [device] [partition] [apply]                               |
## ----------------------------------------------------------------------------------------------------
__parted () {
	__output ${FUNCNAME[0]}
	echofunc ${FUNCNAME[0]}
	_PACK=$(apt list parted)
if [[ $_PACK == *"installed"* ]]; then
	echo "parted exists.."
else
	echoinfo "install parted package ....  "
	apt-get install -y -qq --no-install-recommends parted
fi

[[ -z $_DEV ]] && _DEV=/dev/sda
[[ -z $_PART ]] && _PART=1
[[ -z $_APPLY ]] && _APPLY=apply
[[ -z $_EXT ]] && _EXT="10000MB" # max size 10GB

echoinfo "_DEV=$_DEV; _PART=$_PART; _APPLY=$_APPLY; _EXT=$_EXT"
_USAGE="eg. preview usage: initiv parted /dev/sda 1; apply usage: initiv parted /dev/sda 1 apply"
if [ -z "$_DEV" ]; then
	echowarning "_DEV and _PART are empty... "; echoinfo "$_USAGE"; exit 0
fi
if [ -z "$_PART" ]; then
	echowarning "_PART is empty... "; echoinfo "$_USAGE"; exit 0
fi
fdisk -l $_DEV$_PART >> /dev/null 2>&1 || (echo "could not find $_DEV$_PART - please check" && exit 1)

CURRENTSIZEB=`fdisk -l $_DEV$_PART | grep "Disk $_DEV$_PART" | cut -d' ' -f5`
CURRENTSIZE=`expr $CURRENTSIZEB / 1024 / 1024`
#_EXT=`printf %s\\n 'unit MB print list' | parted | grep "Disk ${_DEV}" | cut -d' ' -f3 | tr -d MB`
echowarning "[ok] would/will resize to from ${CURRENTSIZE}MB to ${_EXT}"

if [[ "$_APPLY" == "apply" ]] ; then
  echo "[ok] applying resize operation.."
  parted ${_DEV} resizepart ${_PART} yes ${_EXT}
  echoinfo "[done]"
else
  echowarning "Sandbox mode, i did not size!. $_USAGE"
fi
(sleep 1; echoinfo "expand filesystem ........... please wait ..."; exit 0) &
#(sleep 2; printf "\n") &
resize2fs $_DEV$_PART 2>/dev/null
}

## -- Function -- __tunning ---------------------------------------------------------------------------
## |    Description: tunning                                                                          |
## ----------------------------------------------------------------------------------------------------
__tunning () {
	__output ${FUNCNAME[0]}
	echofunc ${FUNCNAME[0]}
	echoinfo "modify /etc/ssh/sshd_config: PermitRootLogin yes"
	sed -i 's/without-password/yes/g' /etc/ssh/sshd_config # deb8
	sed -i 's/\#PermitRootLogin\ prohibit-password/PermitRootLogin\ yes/g' /etc/ssh/sshd_config #deb10
	service sshd reload
		echoinfo " ... set /etc/apt/apt.conf: Install-Recommends \"false\""
		rm /etc/apt/apt.conf 2>/dev/null
	echo 'APT::Install-Recommends "false" ; APT::Install-Suggests "false" ;' >> /etc/apt/apt.conf

		echoinfo " ... configure grub, add options .............."
_GRUB="/etc/default/grub" # grub config file
	cp $_GRUB $_GRUB-$_DATE_STAMP
#	sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=0/g' $_GRUB 2>/dev/null
#	sed -i 's/GRUB_CMDLINE_LINUX_DEFAULT="quiet"/GRUB_CMDLINE_LINUX_DEFAULT="quiet loglevel=0 splash rd.udev.log_priority=3 rd.systemd.show_status=false"/g' $_GRUB 2>/dev/null
#	sed -i 's/\#GRUB_GFXMODE=640x480/GRUB_GFXMODE=800x600/g' $_GRUB 2>/dev/null

# add this to skip fsck: GRUB_CMDLINE_LINUX_DEFAULT=fsck.mode=skip
cat > $_GRUB <<	EOF
GRUB_DEFAULT=0
GRUB_TIMEOUT=0
GRUB_DISTRIBUTOR="busy4.me"
GRUB_CMDLINE_LINUX_DEFAULT="quiet loglevel=0 splash rd.udev.log_priority=3 rd.systemd.show_status=false"
GRUB_CMDLINE_LINUX=""
GRUB_GFXMODE=800x600
GRUB_GFXPAYLOAD_LINUX=keep
GRUB_BACKGROUND="/usr/share/images/grub/Plasma-lamp.tga"
EOF
	update-grub 2>/dev/null

# available picture in default Debian 10
# F-16 aeroplan
#	050817-N-3488C-028.tga

# room
#	2006-02-15_Piping.tga

# Apollo rocket
#	Apollo_17_The_Last_Moon_Shot_Edit1.tga

#	B-1B_over_the_pacific_ocean.tga
#	BonsaiTridentMaple.tga
#	Glasses_800_edit.tga
#	Hortensia-1.tga
#	Lake_mapourika_NZ.tga
#	Moraine_Lake_17092005.tga
#	Plasma-lamp.tga
#	TulipStair_QueensHouse_Greenwich.tga
#	Windbuchencom.tga

		echoinfo " ... do not show messages durring boot ........ disable blank console ..."
	sed -i 's/exit 0//g' /etc/rc.local 2>/dev/null
	printf '%s\n%s\n' 'dmesg --console-off' 'exit 0' >> /etc/rc.local
	sed -i 's/#kernel.printk/kernel.printk/g' /etc/sysctl.conf
	if [ -e /etc/default/rcS ];then
		echoinfo " ... modify /etc/default/rcS ..."
		sed -i 's/#VERBOSE/VERBOSE/g' /etc/default/rcS
	else
		echoinfo " ... create /etc/default/rcS file with VERBOSE=no ..."
		touch /etc/default/rcS
		echo 'VERBOSE=no' >> /etc/default/rcS
	fi
	sed -i 's/journal+console/journal/g' /lib/systemd/system/systemd-fsck-root.service
	sed -i 's/journal+console/journal/g' /lib/systemd/system/systemd-fsck@.service
}

## -- Function -- __remove_dirs -----------------------------------------------------------------------
## |    Description: remove directories                                                               |
## ----------------------------------------------------------------------------------------------------
__remove_dirs () {
	echofunc "__remove_dirs"
	echoinfo "remove directories ..."
	if [ $_DIR == "NULL" ]; then
		echoerror "nothing to remove ... add argument please"
	exit 0
	fi
	echowarning "remove $_DIR"
	rm -R $_DIR 2>/dev/null
}

## -- Function -- __remove_files ----------------------------------------------------------------------
## |    Description: remove files                                                                     |
## ----------------------------------------------------------------------------------------------------
##
__remove_files () {
	__output ${FUNCNAME[0]}
	echofunc ${FUNCNAME[0]}
	echoinfo "rm /var/cache/apt/*.bin"
rm /var/cache/apt/*.bin 2>/dev/null
	echoinfo "rm /var/cache/debconf/*"
rm /var/cache/debconf/* 2>/dev/null
	echoinfo "rm /var/cache/apt/archives/*.deb"
rm /var/cache/apt/archives/*.deb 2>/dev/null
	echoinfo "rm /var/lib/apt/lists/*.*"
rm /var/lib/apt/lists/*.* 2>/dev/null
	echoinfo "rm -rf /usr/share/man/??"
rm -rf /usr/share/man/?? && rm -rf /usr/share/man/??_*
# rm -rf /usr/lib/modules/4.19.0-8-amd64/kernel/sound/pci/*
# remove all modules, linux starts fine after that :)
}

## -- Function -- __download_files --------------------------------------------------------------------
## |    Description: download files                                                                   |
## ----------------------------------------------------------------------------------------------------
## |
__download_files () {
# download file "package.tar.gz" and unpack to "archive" directory in declared "/full/path/package"
# help = usage ========================
# ./initiv -d /full/path/package.tar.gz
# all files from package.tar.gz will be extracted to "/full/path/package" directory
#	__file=$__file
__output ${FUNCNAME[0]}
echofunc ${FUNCNAME[0]}
	# server structure /.initiv/debian/10.3/x86_64/
	if [ -f /etc/os-release ]; then
	. /etc/os-release
		_ID=$ID
		_VERSION_CODENAME=$VERSION_CODENAME
		_VERSION_ID=$VERSION_ID
	fi
	if [ -f /etc/debian_version ]; then
		_VER=$(cat /etc/debian_version)
	fi
	_ARCH=$(uname -m)
	_KERNEL_RELEASE="$(uname -r)"
	echoinfo "full server distribution path: $_SERVER/.initiv/$_ID/$_VER/$_ARCH"

# help = usage ============================
# ./initiv download
# will download all files from declared default list
# declare list of full names of files with full paths
if [ -z "$__file" ]; then
	echoinfo "declare list of files ......... wait ..."
	declare -a __files=(
#	"/usr/lib/modules/$_KERNEL_RELEASE.tar.gz" \
	"/usr/share/pixmaps/spin.tar.gz"\
	"/usr/share/pixmaps/dots-mouse/dots-mouse.tar.gz"\
	"/usr/share/pixmaps/red-dots-black/red-dots-black.tar.gz"\
	)
else
	echoinfo "full file name with path $__file"
	__f=$(echo "${__file##*/}") # extract file name without path
	__p=$(echo "${__file%/*}") # extract path only
	echoinfo "file: $__f"
	echoinfo "path: $__p"
	echoinfo "download file: $__p/$__f ............................. wait ..."
	rm -R $__p # delete old package files and directory
	mkdir $__p
	wget -nv -O $__file --no-check-certificate $_SERVER/.initiv/$_ID/$_VER/$_ARCH/$__path/$__file
	tar -C $__p -zxf $__file
	rm -R $__file # clean up
	echoinfo "tar -C $__p -zxvf $__file"; echoinfo "... done"
fi
# __filex=$(echo $__file | sed 's/.*\//') # extract file without path
# __file_path=$(echo $__file | sed 's/$__filex//g') # extract path only, not working with variable
# easy way:
# __file=$(echo "${__file##*/}") # extract file name without path
# __path=$(echo "${__file%/*}") # extract path only
# source: https://stackoverflow.com/questions/4168371/how-can-i-remove-all-text-after-a-character-in-bash
# create archive
# tar -zcvf spin.tar.gz ./spin
# tar -zcvf $_KERNEL_RELEASE.tar.gz /usr/lib/modules/$_KERNEL_RELEASE
# download file:
	for __file in ${__files[@]}; do
		__f=$(echo "${__file##*/}") # extract file name without path
		__p=$(echo "${__file%/*}") # extract path only
		echoinfo "file: $__f"
		echoinfo "path: $__p"
		echoinfo "download file: $__file ............................. wait ..."
		rm -R $__p # delete old package files and directory
		mkdir $__p
		wget -nv -O $__file --no-check-certificate $_SERVER/.initiv/$_ID/$_VER/$_ARCH/$__path/$__file
		tar -C $__p -zxf $__file
		rm -R $__file # clean up
		echoinfo "tar -C $__p -zxvf $__file"; echoinfo "... done"
		done
	# unpack archive
}

__service () { #help: create service
	echofunc ${FUNCNAME[0]}
	systemctl disable ${_SNAME}.service
	systemctl daemon-reload
	echoinfo "create service which runs after reboot"
	if [ -z "$1" ]; then
		echowarning "you must define service name.."
#		exit 1
	fi
	_SNAME=redblack # service name
	if [ -z "$_ANIMEDIR" ]; then
		_ANIMEDIR="/usr/share/pixmaps/red-dots-black"
	fi
cat > /usr/bin/${_SNAME} << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME
echo "_ANIMEDIR:$_ANIMEDIR"
_ANIMEDIR='$_ANIMEDIR'
__anime () {
it="0.04" # interval time
__dirlist=(\`ls \$_ANIMEDIR/\$*\`)
while true; do
	echo "next files from:" \$_ANIMEDIR
	for __file in \${__dirlist[*]}; do
			fbi -1 -T 1 -t 2 -noverbose $_ANIMEDIR/\$__file
			sleep \$it
			fbi -1 -T 1 -t 2 -noverbose $_ANIMEDIR/\$__file
			sleep \$it
		pkill fbi
	done
	echo "stop fbi"
	pkill fbi
	sleep 0.5
done
}
case \$1 in
	start)
	__anime
	;;
	stop)
	_PID=\$(pgrep ${_SNAME} | awk '{print \$1}')
	kill -9 \$_PID
#	pkill ${_SNAME}
	;;
esac
EOF
chmod +x /usr/bin/${_SNAME}

cat > /etc/systemd/system/${_SNAME}.service << EOF
# Contents of /etc/systemd/system/${_SNAME}.service
[Unit]
Description=redblack
After=network.target

[Service]
Type=simple
Restart=always
ExecStart=/usr/bin/$_SNAME start

[Install]
WantedBy=multi-user.target
EOF
systemctl daemon-reload
systemctl enable ${_SNAME}.service
echoinfo "service \"$_SNAME.service\" created, usage: service $_SNAME start|stop"
cat > /root/.profile  << 'EOF'
[[ $(tty) = /dev/tty2 ]] && (ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sed 's/127.0.0.1//' | tr '\n' ' ')
EOF
}


## cat >> ./initivHelp << 'HELP'
## -- Function -- __anime -----------------------------------------------------------------------------
## |    Description: create animation script (wallpaper durring installation)                         |
## |         Option: -n [type]                                                                        |
## |          Types: dark <default>, light, spin                                                      |
## |       Examples: ./initiv -n light # create white background color animation, four color dots     |
## |                 ./initiv -n dark # create black background color animation, three red dots       |
## ----------------------------------------------------------------------------------------------------
__anime () {
	echofunc "__anime"
if [ -z "$_ANIMEDIR" ]; then
	_ANIMEDIR="/usr/share/pixmaps/red-dots-black"
else
	case $_ANIMEDIR in
		"1"|"dark") _ANIMEDIR="/usr/share/pixmaps/red-dots-black"                        ;;
		"2"|"light") _ANIMEDIR="/usr/share/pixmaps/dots-mouse"                           ;;
		"3"|"spin") _ANIMEDIR="/usr/share/pixmaps/spin"                                  ;;
		*) echowarning "usage: $0 anime [1|dark|2|light|3|spin]"; exit 0                 ;;
	esac
fi
echo $_THEME > /opt/anime.theme
echo $_ANIMEDIR > /opt/anime.dir
# xli based on xloadimage
# pictures default directory
echoinfo "_ANIMEDIR:$_ANIMEDIR"
rm /opt/anime.sh 2>/dev/null
cat > /opt/anime.sh << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME
echo "_ANIMEDIR:$_ANIMEDIR"
_ANIMEDIR='$_ANIMEDIR'
__anime () {
it="0.2" # interval time
__dirlist=(`ls \$_ANIMEDIR/\$*`)
while true; do
	for __file in \${__dirlist[*]}; do
#		export DISPLAY=:0 && eval xloadimage -onroot $_ANIMEDIR/\$__file &
		xloadimage -onroot $_ANIMEDIR/\$__file &
		sleep \$it
		pkill xloadimage
		sleep \$it
	done
	pkill xloadimage
	sleep 2
done
}
case \$1 in
	\$1)
		_ANIMEDIR=\$1
		__anime
	;;
	*)
		echo "no arguments"
	;;
esac
EOF
chmod +x /opt/anime.sh

# set user's autostart, xinitrc
cp /home/$_USER/.xinitrc /home/$_USER/.xinitrc.bak 2>/dev/null
rm /home/$_USER/.xinitrc 2>/dev/null
cat > /home/$_USER/.xinitrc  << EOF
# generated by $_SCRIPT_FULL_NAME
#xclock
/opt/anime.sh &
(sleep 2; /opt/xt.sh) &
/opt/osd.sh
EOF
chown $_USER:$_USER /home/$_USER/.xinitrc

# anime by framebuffer
cat > /opt/anime.fb << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME
echo "_ANIMEDIR:$_ANIMEDIR"
_ANIMEDIR='$_ANIMEDIR'
__anime () {
it="0.04" # interval time
__dirlist=(`ls \$_ANIMEDIR/\$*`)
while true; do
	echo "next files from:" \$_ANIMEDIR
	for __file in \${__dirlist[*]}; do
			fbi -1 -T 1 -t 2 -noverbose $_ANIMEDIR/\$__file
			sleep \$it
			fbi -1 -T 1 -t 2 -noverbose $_ANIMEDIR/\$__file
			sleep \$it
		pkill fbi
	done
	echo "stop fbi"
	pkill fbi
	sleep 0.5
done
}
__anime
EOF
chmod +x /opt/anime.fb
}

## -- Function -- __osd -------------------------------------------------------------------------------
## |    Description: create script to display text during installation                                |
## ----------------------------------------------------------------------------------------------------
__osd () {
	echofunc "__osd"
_FC=orange # font color

if [[ "$_THEME" = "light" ]]; then
	_FC=blue
fi
#rm $HOME/osd
#cat > /opt/osd << 'EOF'
#Loading . . .
#EOF
__it="0.5"
# help==============================
# see fonts list, command: xlsfonts
# default font:
#__fo="-misc-fixed-medium-r-semicondensed--*-*-*-*-c-*-*-*"
rm /opt/osd.sh
cat > /opt/osd.sh << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME
__fo="-misc-fixed-bold-r-normal--18-120-100-100-c-90-iso8859-1"
	touch \$HOME/osd
		while true; do
			declare -a _DOTS=("." ".." "...")
			for __dot in \${_DOTS[@]}; do
				__r=\$((RANDOM%2+1)) # random 1 digit
				echo "installing \$__dot" 2>&1 | tee \$HOME/osd
				/usr/bin/osd_cat -p bottom -o 2 -A center -c $_FC -d \$__r -f \$__fo \$HOME/osd
			done
		done
EOF
chmod +x /opt/osd.sh
echoinfo "/opt/osd.sh ... created"
}

## -- Function -- __dots ------------------------------------------------------------------------------
## |    Description: dots                                                                             |
## ----------------------------------------------------------------------------------------------------
__dots () {
	echofunc "__dots"
_TERM=$(tty)
_PROC=$(ps -e | grep "initiv" | grep -v grep)
echoinfo "$_PROC"
(while [[ $_PROC == *"initiv"* ]]; do
	_PROC=$(ps -e | grep "initiv" | grep -v grep)
    printf '.' > $_TERM
    sleep 1
done) &

sleep 5

printf '\n' > $_TERM
(sleep 0.1; pkill initiv) &
}

## -- Function -- __xt -----------------------------------------------------------------------------
## |    Description: create xterminal winodows diplayed durring installation                       |
## -------------------------------------------------------------------------------------------------
__xt () {
echofunc "__xt"
# default theme: dark
case $_THEME in
	"light")
		_BG="white"
		_FG="black"
	;;
	"dark"|*)
		_BG="black"
		_FG="grey"
	;;
esac
echo "switch to $_THEME theme, _BG=$_BG, _FG-$_FG"
echo "$_THEME" > /opt/xt.theme # save value in file

# run xterm with scpecific parameters
cat > /opt/xt.sh << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME
__time () {
	declare -a _DOTS=("0." "1.." "2..." "3...." "4....." "5....." "6......." "7........" "8........." "9..........")
	_START=\$(date +%s)
while true; do
	_ELAPSED=\$((\$(date +%s) - \${_START}))
	for _DOT in \${_DOTS[@]}; do
	echo -ne \$(date -ud "@\$_ELAPSED" +'busy4.me %H:%M:%S')"'\${_DOT}\033[0K\r"
	sleep 0.1
	done
done
}

__count () {
	# generate specific output in terminal
	__ms=\$((10 * 100000))
	echo -e -n "\x1b[\x36 q" # change cursor to steady bar
	while true; do
		__c=\$(( __c+1 ))
		echo -ne " \$__ms \033[0K\r \$__c "
		sleep 0.01
		: \$(( __ms-- ))
	done
}

__ip () {
	# generate IP output in terminal
	_IP=\$(ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sed 's/127.0.0.1//' | tr '\n' ' ')
  while [ -z \$_IP ]; do
		_IP=\$(ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sed 's/127.0.0.1//' | tr '\n' ' ')
	sleep 1
	done
	echo "\$_IP" | tr '\n' ' '
	sleep infinity
}

__message () {
	_MESSAGE=\${1}
	echo "\${1}" | tr '\n' ' '
	sleep infinity
}

__xterm () {
	__font="-misc-fixed-bold-r-normal--18-120-100-100-c-90-iso8859-1"
	# xterm -geometry 30x20+0+0 -uc -bg black -fg grey -fn \$__font -e /opt/count.sh
	xterm -geometry 50x3+10+10 -bw 0 -uc -bg $_BG -fg $_FG -fn \$__font -e '/opt/xt.sh time' &
	xterm -geometry 17x2+650+545 -bw 0 -uc -bg $_BG -fg $_FG -fn \$__font -e '/opt/xt.sh ip'
}

case \$1 in
	message) __message \${2} ;;
	time) __time ;;
	count) __count ;;
	ip) __ip       ;;
	*) __xterm     ;;
esac
EOF
chmod +x /opt/xt.sh
echoinfo "/opt/xt.sh ... created"
}

## -- Function -- __new_hostname -------------------------------------------------------------------
## |    Description: new hostname                                                                  |
## -------------------------------------------------------------------------------------------------
__new_hostname () {
	__output ${FUNCNAME[0]}
	echofunc ${FUNCNAME[0]}
	echoinfo "change hostname to \"$_NEW_HOSTNAME\""
}

## -- Function -- __update -------------------------------------------------------------------------
## |    Description: update initiv itself                                                          |
## -------------------------------------------------------------------------------------------------
__update () { #help: ./initiv update itself
	__output ${FUNCNAME[0]}
	echofunc ${FUNCNAME[0]}
	echoinfo " ..download update on server $_SERVER"
	echo -e "$0 \e[32m -- Update $_SCRIPT_VERSION $_DATE_STAMP\e[0m"
	if ! wget -nv -O ./initiv.new --no-check-certificate $_SERVER/initiv; then
		echoerror "there is no file "$0" on the server or no response!..."
		exit 1
	else
		echoinfo " ... compare version"
		_NEW="$(cat ./initiv.new | base64)"
		_OLD="$(cat ./initiv | base64)"
		if [ ! "$_NEW" == "$_OLD" ]; then
			echowarning " ... version on the server is different, update and start again..."
			rm -rf ./initiv-*;	cp ./initiv ./initiv-$_DATE_STAMP # backup just in case
			rm -rf ./initiv;	cp ./initiv.new ./initiv 2>/dev/null
			chmod +x ./initiv
			rm -rf ./initiv.new
			echo "run again: " $_SCRIPT_FULL_NAME $_SCRIPT_ARGUMENTS
$_SCRIPT_FULL_NAME $_SCRIPT_ARGUMENTS
exit 0
		else
			echoconfirm " ... no update needed, identical version on the server"
		fi
fi
}

## -- Function -- __salt ---------------------------------------------------------------------------
## |    Description: install saltstack                                                             |
## -------------------------------------------------------------------------------------------------
## |
__salt () { #help: install salt-minion, UUID used as minion ID if not provided, restart salt-minion service
	__output ${FUNCNAME[0]}
	echofunc ${FUNCNAME[0]}
	echoinfo " ... install saltstack, _SALT_MASTER=$_SALT_MASTER"
	__install_stuff1 gnupg
wget -O - http://repo.saltstack.com/py3/debian/10/amd64/latest/SALTSTACK-GPG-KEY.pub | apt-key add -
echo "deb http://repo.saltstack.com/py3/debian/10/amd64/latest buster main" >> /etc/apt/sources.list
apt update
apt install -y salt-common salt-minion
	# Drop the master address if passed
[ ! -d "$_SALT_DIR/minion.d" ] && mkdir -p "$_SALT_DIR/minion.d"
cat > $_SALT_DIR/minion.d/99-master-address.conf << EOF
master: $_SALT_MASTER
EOF
	# Drop the minion id if passed
[ ! -d "$_SALT_DIR" ] && mkdir -p "$_SALT_DIR"
echo "$_SALT_MINION" > "$_SALT_DIR/minion_id"
service salt-minion restart &&
echoinfo "salt-minin ID: $_SALT_MINION"
service salt-minion status
}

__show () {
	echofunc ${FUNCNAME[0]}
	export DISPLAY=:0
	export XAUTHORITY='/home/'$_USER'/.Xauthority'
	_BG=black
	_FG=grey
	__font="-misc-fixed-bold-r-normal--18-120-100-100-c-90-iso8859-1"
	_MESSAGE="$1"
	echoinfo "$_MESSAGE"
	if [ -n $1 ]; then
		xterm -geometry 105x5+1+540 -bw 0 -uc -bg $_BG -fg red -fn $__font -e '/opt/xt.sh message '$_MESSAGE
		exit 0
	fi
	_PROC="osd.sh" 	# looking for process
	_CHECK=$(ps -e | grep $_PROC | grep -v grep)
	while [[ ! $_CHECK == *$_PROC* ]]; do
		_CHECK=$(ps -e | grep $_PROC | grep -v grep)
		echoerror "there is no process $_PROC? check: $_CHECK ... wait"
		sleep 5
	done
	echowarning "process $_PROC running! check: $_CHECK"
echo ":~# ps -e | grep $_PROC | grep -v grep"
ps -e | grep $_PROC | grep -v grep
	# install progress in xterm during first interface...
#	xterm -geometry 105x4+10+540 -bw 0 -uc -bg $_BG -fg $_FG -fn $__font -e '/root/initiv removePackages'
while true; do
	xterm -geometry 105x5+1+540 -bw 0 -uc -bg $_BG -fg $_FG -e '/root/initiv removePackages'
	xterm -geometry 105x5+1+540 -bw 0 -uc -bg $_BG -fg $_FG -e '/root/initiv apt1'
	xterm -geometry 105x5+1+540 -bw 0 -uc -bg $_BG -fg $_FG -e '/root/initiv tunning'
done
}

__prepare () {
	echofunc ${FUNCNAME[0]}
cat > /opt/check << EOF
#!/bin/bash
# generated by $_SCRIPT_FULL_NAME
_PROC="osd.sh" 	# looking for process
_CHECK=\$(ps -e | grep \$_PROC | grep -v grep)
while [[ ! \$_CHECK == *\$_PROC* ]]; do
	_CHECK=\$(ps -e | grep \$_PROC | grep -v grep)
	echo "there is no process \$_PROC? check: \$_CHECK ... wait"
	sleep 5
done
echowarning "process \$_PROC running! check: \$_CHECK"
echo ":~# ps -e | grep \$_PROC | grep -v grep"
ps -e | grep \$_PROC | grep -v grep
$_SCRIPT_FULL_NAME -S 1
EOF
chmod +x /opt/check
echoinfo "/opt/check ... created"

# create "check" service
# or login as root and execute as below:
# mkdir -pv /etc/systemd/system/getty@tty2.service.d 2>/dev/null
# rm /etc/systemd/system/getty@tty2.service.d/autologin.conf 2>/dev/null
# cat > /etc/systemd/system/getty@tty2.service.d/autologin.conf << EOF
# [Service]
# ExecStart=
# ExecStart=-/sbin/agetty --autologin root --noclear %I $TERM
# EOF
# systemctl set-default multi-user.target

cat > /root/.profile  << 'EOF'
[[ $(tty) = /dev/tty2 ]] && /opt/check
EOF

_PROC="osd.sh" 	# looking for process
_CHECK=$(ps -e | grep $_PROC | grep -v grep)
while [[ ! $_CHECK == *$_PROC* ]]; do
	_CHECK=$(ps -e | grep $_PROC | grep -v grep)
	echo "there is no process $_PROC? check: $_CHECK ... wait"
	sleep 5
done
echowarning "process $_PROC running! check: $_CHECK"
echo ":~# ps -e | grep $_PROC | grep -v grep"
ps -e | grep $_PROC | grep -v grep
if [[ $_CHECK == *$_PROC* ]]; then
	$_SCRIPT_FULL_NAME show PREPARED! &
fi
}

__no_option () {
	echofunc ${FUNCNAME[0]}
	echo -e "${lred}Option does not exist :${lyel} -$OPTARG, ${coloroff} type $0 -h for help"
}

__debfoster () {
	echofunc ${FUNCNAME[0]}
	echoinfo "remove packages using debfoster"
	apt -y install debfoster
	debfoster -q
}

__install_x () {
	echofunc ${FUNCNAME[0]}
	echoinfo "install X"
apt-get install -y -V --no-install-recommends xorg
}

__interface () {
	echofunc ${FUNCNAME[0]}
	echoinfo "set interface ..."
picture="wallpaper.jpg"
	rm /opt/$picture 2>/dev/null
	wget -nv -O /opt/$picture --no-check-certificate $_SERVER/$picture
chmod 777 /opt/$picture
}

__count () { #help: generate specific output in terminal
	echofunc ${FUNCNAME[0]}
	__ms=$((10 * 100000))
	echo -e -n "\x1b[\x36 q" # change cursor to steady bar
	while true; do
		__c=$(( __c+1 ))
		echo -ne " $__ms \033[0K\r $__c "
		sleep 0.01
		: $(( __ms-- ))
	done
}

__timer () { #help: Generate one line time counter in Hours,Minutes,Second and deciseconds with nice dots
echofunc ${FUNCNAME[0]}
cat > /opt/timer << EOF
#!/bin/bash
declare -a _DOTS=("0." "1.." "2..." "3...." "4....." "5....." "6......." "7........" "8........." "9..........")
_START=\$(date +%s)
while true; do
	_ELAPSED=\$((\$(date +%s) - \${_START}))
	for _DOT in \${_DOTS[@]}; do
		echo -ne \$(date -ud "@\$_ELAPSED" +'Time elapsed: %H hours %M minutes %S seconds')"'\${_DOT}\033[0K\r"
		sleep 0.1
	done
done
EOF
chmod +x /opt/timer
echoinfo "/opt/timer ... created, usege: /opt/timer"

	declare -a _DOTS=("0." "1.." "2..." "3...." "4....." "5....." "6......." "7........" "8........." "9..........")
	_START=$(date +%s)
while true; do
	_ELAPSED=$(($(date +%s) - ${_START}))
	for _DOT in ${_DOTS[@]}; do
		echo -e -n "\x1b[\x36 q" # change cursor to steady bar
		echo -ne $(date -ud "@$_ELAPSED" +'Time elapsed: %H hours %M minutes %S seconds')"'${_DOT}\033[0K\r"
		sleep 0.1
	done
done
}

__timer2 () {
	echofunc ${FUNCNAME[0]}
_START=$(date +%s)
declare -a _DOTS=("0." "1.." "2..." "3...." "4....." "5....." "6......." "7........" "8........." "9..........")
while true; do
	_ELAPSED=$(($(date +%s) - ${_START}))
	if [[ -z ${_ELAPSED} || ${_ELAPSED} -lt 60 ]] ;then
			min=0 ; secs="${_ELAPSED}"
	else
			time_mins=$(echo "scale=2; ${_ELAPSED}/60" | bc)
			min=$(echo ${time_mins} | cut -d'.' -f1)
			secs="0.$(echo ${time_mins} | cut -d'.' -f2)"
			secs=$(echo ${secs}*60|bc|awk '{print int($_ELAPSED+0.5)}')
	fi
	for _DOT in ${_DOTS[@]}; do
		echo -ne "Time elapsed : 0:${min}:${secs}'${_DOT}\033[0K\r"
		sleep 0.1
	done
	#	_MS=0
	#	while [ $_MS -lt 9 ]; do
	#		_MS=$((${_MS} + 1))
	#echo -ne "Time elapsed : 0:${min}:${secs}.${_MS}\033[0K\r"
	#	done
done
}

__version() { #help: show help...
echo -e "\e[95m$0 -- Version $_SCRIPT_VERSION\e[0m"
}

__help () { #help: show short functions descriptions
__output ${FUNCNAME[0]}
echofunc ${FUNCNAME[0]}
echoinfo "=== $_SCRIPT_NAME === Ver.$_SCRIPT_VERSION ======== help =============="
  LANG=en_US.UTF_8
	grep -E '^##' "$0" | sed -e 's|##|\||g' | column -s"|" -t
echo -e "\e[32m  =================== help file end ==============\e[0m"
}

__func_help () { #help: show short functions descriptions
echoinfo "=== $_SCRIPT_NAME === Ver.$_SCRIPT_VERSION ======== help =============="
echofunc "__func_help"
  LANG=en_US.UTF_8
echoinfo "=== Functions list ==="
  grep -E '^_.+ #help' "$0" | sed -e 's|() { #help: |.|g' | column -s"..." -t | sort
}

__stuff_help () { #help: show short functions descriptions
echofunc "__stuff_help"
  LANG=en_US.UTF_8
echoinfo "=== Stuff list ==="
echoinfo "   *TODO"
}

##
cat > ./updated << EOF
## === udpate every time ===========================================================================
## | run automaticaly udate every time on start!
## | try ./initiv -k                                                   |
## =================================================================================================
EOF
## __update

##
## === options =====================================================================================
## | pass options with or without parameters                                                       |
## =================================================================================================
## Available options:
##
while getopts ':a: b d: f F h H: i: k l n: o: r: s: S v T: t: u U: w x X' opt
do
  case "${opt}" in
    a ) _AUTOUSER="$OPTARG"; __autologin; __autostart                                       ;;
## -a <user>	set who will be automaticaly logged in tty1, start X session and execute X apps
		b ) __install_stuff4; exit 0                                                            ;;
## -b		install stuff4 & exit (List of stuff: ./initiv -l)
## -c		option "c"
		d ) __file="$OPTARG"; __download_files; exit 0                                          ;;
## -d <file>	download specific file, eg,: initiv -d file.txt
## -e		option "e"
		f ) [[ -n $2 ]] && $2;  __func_help                                                     ;;
## -f		show all functions short descriptions
## -f <function>	execute specific function!
		F ) __fix                                                                               ;;
## -F	fix possible problems with filesystem, databeses, apt, dpkg etc
## 		examples: ./initiv -f __timer	# execute __timer function
## -g		option "g"
    h|\? ) __help; exit 0                                                                   ;;
## -h	or -?	this help
		H ) _THEME="$OPTARG"; _ANIMEDIR="$OPTARG"; __anime; __xt; __osd; __reset                ;;
## -H <value>	Pass the loading theme. values: <light> or <dark> (default)
		i ) _PACKAGE="$OPTARG"; __install_stuff                                                 ;;
## -i <package>	Install particular package, could be defined short name, eg. initiv -p ssh
## 		available short names: ssh (install openssh-server)
##
## -j		option "j"
		k ) _SKIP_UPDATE="true"                                                                 ;;
## -k		skip auto update *TODO
		l ) __stuff_help                                                                        ;;
## -l		Stuff list *TODO
## -m		option "m"
		n )  _ANIMEDIR="$OPTARG"; echoinfo "_ANIMEDIR=$OPTARG"                                   ;;
## -n <dir)	Set background animation, where <dir> contains pictures for animation *TODO
		r ) _DIR="$OPTARG"; __remove_dirs; exit 0                                               ;;
## -r <dir>	remove particular directories *TODO
		s ) _SALT_MASTER="$OPTARG"                                                              ;;
## -s <server>	set salt-master server IP address or DNS name (default: saltmaster.localhost)
## 		stored in ${_SALT_DIR}/minion.d/99-master-address.conf
		S ) _SHOW="true"                                                                         ;;
## show execution in xterm, on tty1, user's X session
## use this option if you want see output on DISPLAY:0 instead terminal
		t ) _SALT_MINION="$OPTARG"                                                              ;;
## -t <name>	set salt-minion ID (default: machine UUID)
## 		stored in ${_SALT_DIR}/minion_id
    T ) _NEW_HOSTNAME="$OPTARG"; __new_hostname                                             ;;
## -T <hostname>	pass host name value and execute change hostname -T hostname, -T node (default)
## -q		option "q"
		u ) __update; __version                                                                 ;;
## -u		Update itself (download new version from server and replace the script)
		U ) _USER="$OPTARG"; __useradd; __anime; __autologin; __autostart; __reset              ;;
## -U <username>	Add user to the system, set autologin and autostart, reset xinit(Xorg) in tty1
		v ) __version                                                                           ;;
## -v		Display script version
		w ) __update_apt_repos                                                                  ;;
# -w		update default apt repos
		x ) _XT="YES"; echoinfo "run in the screen DISPLAY :0"                                  ;;
## -x		run command in xterminal (durring the first interface screen)
		X ) __install_x; (sleep 2; __reset) &                                                   ;;
## -X		install X server and reset tty1
## -y		option "y"
## -z		option "z"
		:) echowarning "Option -$OPTARG requires an argument." >&2        		                   ;;
		* )  __help; exit 0                                                                      ;;
  esac
done
shift $((OPTIND-1))

## === actions ======================================================================================
## | actions                                                                                        |
## ==================================================================================================
## |
## Available actions:
##
case $1 in
	"update" )	__update                                                                 ;;
## update||update itself
	"updateApt"|"aptUpdate"|"apt" )	__update_apt_repos                                   ;;
## aptUpdate|update apt repos
	"removeFiles"|"remove-files" )	__remove_files                                       ;;
## remove_files - remove unneded files
	"removePackages"|"remove-packages" )	__remove_packages                              ;;
## remove_packages - remove unnided packages
	"autostart"|"autostartSet"|"autostart-set" )	__autostart                            ;;
## autostart	set programs tu run in user files: .profile and .xinitrc
	"autologin"|"autologinSet"|"autologin-set" )	__autologin                            ;;
## autologin	set who will be logged in tty1
	"tunning" )	__tunning                                                                ;;
## tunning	visual cosmetic tunning
	"installStuff1"|"install-stuff1"|"apt1" )	__install_stuff1                           ;;
## apt1	install stuff from apt
	"installStuff2"|"install-stuff2"|"apt2" )	__install_stuff2                           ;;
## apt2	install stuff2 from apt
	"installStuff3"|"install-stuff3"|"apt3" )	__install_stuff3                           ;;
## apt3	install stuff3 from apt
	"salt" ) __salt                                                                      ;;
## salt - install salt minion
	"installX"|"install-x" )	__install_x                                                ;;
## installX	install Xorg server
	"interface" )	__interface                                                            ;;
	"download" )	__download_files                                                       ;;
	"anime"|"spin"|"animation" )	_ANIMEDIR="$2"; __download_files; __anime              ;;
	"osd" )	__osd                                                                        ;;
	"reset" )	__reset                                                                    ;;
## reset	reset xinit (X server) and all child processes in tty1
	"xt" )	__xt                                                                         ;;
## xt	create xt.sh script, executed in first install screen
	"dots" )	__dots                                                                     ;;
	"createRecovery"|"create-recovery" )	__create_recovery                              ;;
	"parted" )	_DEV=$2; _PART=$3; _APPLY=$4; __parted                                   ;;
## parted	expand partition to default 10GB
	"busy" )	__install_stuff4                                                           ;;
## busy	install stuff4, download and execute script init-1
	"timer" )	__timer                                                                    ;;
## timer	show timer test
	"show" )	__show $2                                                                  ;;
## show	run xterm small window with installation scripts
	"service" )	__service $2                                                             ;;
## create service
	"prepare" )	__prepare                                                                ;;
## prepare	set distro to distribution
	"install" )
		__read_data
		__install
		__remove_packages
		__useradd
		__autostart
		__autologin
		__tunning
		__interface
		__download_files
		__anime
		__read_data
		;;
## install basic packages for splash and first boot
	"0" )
## 0	execute all initial options, remove packages, set user, install X and basic stuff
		__read_data
		__update
		__update_apt_repos
		__install_stuff1
		__install_x
		__download_files
		__anime
		__osd
		__xt
		__read_data
		(sleep 2; __reset) &
		(sleep 10; $_SCRIPT_FULL_NAME prepare) &
		;;
	"1" )
## 1	execute installation process just after download and first run by user
#		echoinfo "__parted"
		__parted
		__fix
		__salt
		__install_stuff2
		__install_stuff3
		__install_stuff4
		__reset
		;;
	"2" )
## 2	download and run init-1 script which next install busy4.me package and reboot
		__install_stuff4
		;;
	$1)
	$1
	;;
	*)
	 	__help
		;;
esac
##
## Examples:
## ./initiv -U baltazar	#create user "baltasar", set autologin and autostart, reset tty1
## ./initiv 0		#virgin init on fresh distro, remove packages, tunning, install stuff,
##			prepare 1st interface)
## ./initiv 1		#install stuff just after 1st run in VM, download ./inti-1 (install busy4me in /opt)
## ./initiv 2		#
## ./initiv -u		#update itself
## ./initiv -S apt	#show apt update in the screen :0
## ./initiv -S apt1	#show suff1 installation in the screen :0
## ./initiv -S __download_files	#show files download process in the screen :0
## ./initiv prepare	#set to run all intallation process after next reboot, use it when you want prepare
##		and distribute. CAUNTION! after next run, partition will be expanded and the filesystem will
##		grow a lot when all stuff will be installed
## ./initiv -S 1	CAUTION! install all stuff
## ./initiv -a user1 -n light -A "master.hipposite.com" install
##
## ./initiv -s '192.168.1.30' -t 'saltminionID' salt
##		install saltstack with salt-master and salt-minion defined
##
##
[[ -f ./initivRecovery ]] ||	{ echoinfo "create script initivRecovery ... "; __create_recovery; }

echo -e $coloroff
secs_to_human "$(($(date +%s) - ${_START}))"
exit 0
